
// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Replace the existing orderFormData state
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Selected order types for single selection
//   // Remove this line: `const [selectedOrderTypes, setSelectedOrderTypes] = useState<string[]>([])`

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: false, // Always default to No (false)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })

//       // Set fallback data only if the API call fails
//       setChecklistTemplate([
//         {
//           id: "general",
//           name: "General Checklist",
//           description: "General quality control items",
//           items: [
//             {
//               id: "general-1",
//               description: "Complete all required documentation",
//               required: false, // Default to No
//               remarks: "", // Leave blank
//               category: "Documentation",
//               isActive: true,
//               createdBy: "System",
//               sectionId: "general",
//             },
//           ],
//         },
//       ])
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validate Job ID
//     const jobIdError = validateJobId(formData.jobId)
//     if (jobIdError) {
//       toast({
//         title: "Validation Error",
//         description: jobIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Validate Assembly ID
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     if (assemblyIdError) {
//       toast({
//         title: "Validation Error",
//         description: assemblyIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data - only include modified items
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Only include items that have been modified
//               const modifiedItems = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return (
//                     modifications &&
//                     (modifications.required !== item.required || modifications.remarks !== item.remarks)
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has modified items
//               return modifiedItems.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: modifiedItems,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: [
//           {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && { fileAction: orderFormData.fileAction }),
//             markComplete: orderFormData.markComplete,
//             documentControlId: orderFormData.documentControlId || null,
//           },
//         ],
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle specific error cases
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("jobId")) {
//           toast({
//             title: "Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           // Focus on the jobId field
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           // Focus on the assemblyId field
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//         } else {
//           toast({
//             title: "Duplicate Entry",
//             description: "One or more fields already exist. Please check your input values.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         // Generic error handling
//         toast({
//           title: "Submission Error",
//           description: error.message || "Failed to save MPI. Please try again.",
//           variant: "destructive",
//         })
//       }
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//               {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     return (
//       formData.jobId.trim() &&
//       formData.assemblyId.trim() &&
//       !validateJobId(formData.jobId) &&
//       !validateAssemblyId(formData.assemblyId) &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Station Selection
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${
//                                 formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${
//                                 formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-3">
//                           <Label>Order Type (Multiple Selection)</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="border rounded-lg p-4 max-h-40 overflow-y-auto">
//                                 <div className="space-y-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action (Multiple Selection)</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="border rounded-lg p-4 max-h-40 overflow-y-auto">
//                                 <div className="space-y-3">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>
//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">{section.description}</p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {/* Station Selection Dropdown */}
//                       <div className="space-y-3">
//                         <Label>Select Stations (Multiple Selection)</Label>
//                         {loadingStations ? (
//                           <div className="flex items-center gap-2">
//                             <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                             <span className="text-sm text-muted-foreground">Loading stations...</span>
//                           </div>
//                         ) : availableStations.length === 0 ? (
//                           <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                             <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                           </div>
//                         ) : (
//                           <div className="space-y-4">
//                             {/* Multi-select dropdown simulation using checkboxes */}
//                             <div className="border rounded-lg p-4 max-h-60 overflow-y-auto">
//                               <div className="space-y-3">
//                                 {availableStations.map((station) => (
//                                   <div key={station.id} className="flex items-center space-x-3">
//                                     <Checkbox
//                                       id={`station-select-${station.id}`}
//                                       checked={formData.selectedStationIds.includes(station.id)}
//                                       onCheckedChange={(checked) => {
//                                         if (checked) {
//                                           handleStationSelectionChange([...formData.selectedStationIds, station.id])
//                                         } else {
//                                           handleStationSelectionChange(
//                                             formData.selectedStationIds.filter((id) => id !== station.id),
//                                           )
//                                         }
//                                       }}
//                                     />
//                                     <div className="flex-1">
//                                       <Label
//                                         htmlFor={`station-select-${station.id}`}
//                                         className="cursor-pointer font-medium text-sm"
//                                       >
//                                         {station.stationName}
//                                       </Label>
//                                       <p className="text-xs text-muted-foreground">
//                                         ID: {station.stationId} • Location: {station.location}
//                                         {station.specifications && station.specifications.length > 0 && (
//                                           <span className="ml-2">• {station.specifications.length} specifications</span>
//                                         )}
//                                       </p>
//                                     </div>
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>

//                             {/* Selected Stations Summary */}
//                             {formData.selectedStationIds.length > 0 && (
//                               <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
//                                 <h4 className="font-medium text-blue-800 mb-3">
//                                   Selected Stations ({formData.selectedStationIds.length})
//                                 </h4>
//                                 <div className="flex flex-wrap gap-2">
//                                   {selectedStations.map((station) => (
//                                     <Badge key={station.id} variant="outline" className="bg-white">
//                                       {station.stationName}
//                                       {station.specifications && station.specifications.length > 0 && (
//                                         <span className="ml-1 text-xs">({station.specifications.length} specs)</span>
//                                       )}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         )}
//                       </div>

//                       {/* Station Specifications */}
//                       {selectedStations.length > 0 && (
//                         <div className="space-y-6">
//                           <div className="border-t pt-6">
//                             <h4 className="font-medium text-lg mb-4">Station Specifications</h4>
//                             <Accordion type="multiple" className="w-full space-y-4">
//                               {selectedStations.map((station) => (
//                                 <AccordionItem key={station.id} value={station.id} className="border rounded-lg">
//                                   <AccordionTrigger className="px-4 py-3 hover:no-underline">
//                                     <div className="flex items-center gap-3 w-full">
//                                       <Factory className="w-5 h-5 text-purple-600" />
//                                       <div className="flex-1 text-left">
//                                         <div className="flex items-center gap-2">
//                                           <span className="font-medium text-lg">{station.stationName}</span>
//                                           <Badge variant="outline">{station.stationId}</Badge>
//                                           <Badge variant="secondary">{station.status}</Badge>
//                                         </div>
//                                         <p className="text-sm text-muted-foreground mt-1">
//                                           Location: {station.location}
//                                           {station.operator && ` • Operator: ${station.operator}`}
//                                           {station.specifications && station.specifications.length > 0 && (
//                                             <span className="ml-2">
//                                               • {station.specifications.length} specifications
//                                             </span>
//                                           )}
//                                         </p>
//                                       </div>
//                                     </div>
//                                   </AccordionTrigger>
//                                   <AccordionContent className="px-4 pb-4">
//                                     <div className="border-t pt-4">
//                                       {station.specifications && station.specifications.length > 0 ? (
//                                         <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
//                                           {station.specifications.map((spec) => (
//                                             <div key={spec.id} className="space-y-3 p-4 bg-gray-50 rounded-lg border">
//                                               {renderSpecificationInput(spec, station.id)}
//                                             </div>
//                                           ))}
//                                         </div>
//                                       ) : (
//                                         <div className="text-center py-8">
//                                           <p className="text-muted-foreground">
//                                             No specifications available for this station.
//                                           </p>
//                                         </div>
//                                       )}
//                                     </div>
//                                   </AccordionContent>
//                                 </AccordionItem>
//                               ))}
//                             </Accordion>
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }
















// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: false, // Always default to No (false)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })


//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validate Job ID
//     const jobIdError = validateJobId(formData.jobId)
//     if (jobIdError) {
//       toast({
//         title: "Validation Error",
//         description: jobIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Validate Assembly ID
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     if (assemblyIdError) {
//       toast({
//         title: "Validation Error",
//         description: assemblyIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data - only include modified items
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//           .map((section) => {
//             // Only include items that have been modified
//             const modifiedItems = (section.items || [])
//               .filter((item) => {
//                 const modifications = checklistModifications[item.id]
//                 return (
//                   modifications &&
//                   (modifications.required !== item.required || modifications.remarks !== item.remarks)
//                 )
//               })
//               .map((item) => {
//                 const modifications = checklistModifications[item.id]
//                 return {
//                   description: item.description,
//                   required: modifications?.required ?? item.required,
//                   remarks: modifications?.remarks ?? item.remarks,
//                   createdBy: item.createdBy || "System",
//                   isActive: item.isActive !== undefined ? item.isActive : true,
//                   category: item.category || section.name,
//                 }
//               })

//             // Only return section if it has modified items
//             return modifiedItems.length > 0
//               ? {
//                 name: section.name,
//                 checklistItems: modifiedItems,
//               }
//               : null
//           })
//           .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           orderType: orderFormData.orderType.length === 1 ? orderFormData.orderType[0] : orderFormData.orderType,
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction.length === 1 ? orderFormData.fileAction[0] : orderFormData.fileAction,
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle specific error cases
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("jobId")) {
//           toast({
//             title: "Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           // Focus on the jobId field
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           // Focus on the assemblyId field
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//         } else {
//           toast({
//             title: "Duplicate Entry",
//             description: "One or more fields already exist. Please check your input values.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         // Generic error handling
//         toast({
//           title: "Submission Error",
//           description: error.message || "Failed to save MPI. Please try again.",
//           variant: "destructive",
//         })
//       }
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//               {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     return (
//       formData.jobId.trim() &&
//       formData.assemblyId.trim() &&
//       !validateJobId(formData.jobId) &&
//       !validateAssemblyId(formData.assemblyId) &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Station Selection
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                                 }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                                 }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">


//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>



//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>


//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                       </div>



//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">

//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type]);
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             );
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action]);
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             );
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>




//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>



//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">{section.description}</p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {/* Station Selection Dropdown */}
//                       <div className="space-y-3">
//                         <Label>Select Stations (Multiple Selection)</Label>
//                         {loadingStations ? (
//                           <div className="flex items-center gap-2">
//                             <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                             <span className="text-sm text-muted-foreground">Loading stations...</span>
//                           </div>
//                         ) : availableStations.length === 0 ? (
//                           <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                             <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                           </div>
//                         ) : (
//                           <div className="space-y-4">
//                             {/* Multi-select dropdown simulation using checkboxes */}
//                             <div className="border rounded-lg p-4 max-h-60 overflow-y-auto">
//                               <div className="space-y-3">
//                                 {availableStations.map((station) => (
//                                   <div key={station.id} className="flex items-center space-x-3">
//                                     <Checkbox
//                                       id={`station-select-${station.id}`}
//                                       checked={formData.selectedStationIds.includes(station.id)}
//                                       onCheckedChange={(checked) => {
//                                         if (checked) {
//                                           handleStationSelectionChange([...formData.selectedStationIds, station.id])
//                                         } else {
//                                           handleStationSelectionChange(
//                                             formData.selectedStationIds.filter((id) => id !== station.id),
//                                           )
//                                         }
//                                       }}
//                                     />
//                                     <div className="flex-1">
//                                       <Label
//                                         htmlFor={`station-select-${station.id}`}
//                                         className="cursor-pointer font-medium text-sm"
//                                       >
//                                         {station.stationName}
//                                       </Label>
//                                       <p className="text-xs text-muted-foreground">
//                                         ID: {station.stationId} • Location: {station.location}
//                                         {station.specifications && station.specifications.length > 0 && (
//                                           <span className="ml-2">• {station.specifications.length} specifications</span>
//                                         )}
//                                       </p>
//                                     </div>
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>

//                             {/* Selected Stations Summary */}
//                             {formData.selectedStationIds.length > 0 && (
//                               <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
//                                 <h4 className="font-medium text-blue-800 mb-3">
//                                   Selected Stations ({formData.selectedStationIds.length})
//                                 </h4>
//                                 <div className="flex flex-wrap gap-2">
//                                   {selectedStations.map((station) => (
//                                     <Badge key={station.id} variant="outline" className="bg-white">
//                                       {station.stationName}
//                                       {station.specifications && station.specifications.length > 0 && (
//                                         <span className="ml-1 text-xs">({station.specifications.length} specs)</span>
//                                       )}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         )}
//                       </div>

//                       {/* Station Specifications */}
//                       {selectedStations.length > 0 && (
//                         <div className="space-y-6">
//                           <div className="border-t pt-6">
//                             <h4 className="font-medium text-lg mb-4">Station Specifications</h4>
//                             <Accordion type="multiple" className="w-full space-y-4">
//                               {selectedStations.map((station) => (
//                                 <AccordionItem key={station.id} value={station.id} className="border rounded-lg">
//                                   <AccordionTrigger className="px-4 py-3 hover:no-underline">
//                                     <div className="flex items-center gap-3 w-full">
//                                       <Factory className="w-5 h-5 text-purple-600" />
//                                       <div className="flex-1 text-left">
//                                         <div className="flex items-center gap-2">
//                                           <span className="font-medium text-lg">{station.stationName}</span>
//                                           <Badge variant="outline">{station.stationId}</Badge>
//                                           <Badge variant="secondary">{station.status}</Badge>
//                                         </div>
//                                         <p className="text-sm text-muted-foreground mt-1">
//                                           Location: {station.location}
//                                           {station.operator && ` • Operator: ${station.operator}`}
//                                           {station.specifications && station.specifications.length > 0 && (
//                                             <span className="ml-2">
//                                               • {station.specifications.length} specifications
//                                             </span>
//                                           )}
//                                         </p>
//                                       </div>
//                                     </div>
//                                   </AccordionTrigger>
//                                   <AccordionContent className="px-4 pb-4">
//                                     <div className="border-t pt-4">
//                                       {station.specifications && station.specifications.length > 0 ? (
//                                         <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
//                                           {station.specifications.map((spec) => (
//                                             <div key={spec.id} className="space-y-3 p-4 bg-gray-50 rounded-lg border">
//                                               {renderSpecificationInput(spec, station.id)}
//                                             </div>
//                                           ))}
//                                         </div>
//                                       ) : (
//                                         <div className="text-center py-8">
//                                           <p className="text-muted-foreground">
//                                             No specifications available for this station.
//                                           </p>
//                                         </div>
//                                       )}
//                                     </div>
//                                   </AccordionContent>
//                                 </AccordionItem>
//                               ))}
//                             </Accordion>
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }





























// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validate Job ID
//     const jobIdError = validateJobId(formData.jobId)
//     if (jobIdError) {
//       toast({
//         title: "Validation Error",
//         description: jobIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Validate Assembly ID
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     if (assemblyIdError) {
//       toast({
//         title: "Validation Error",
//         description: assemblyIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           orderType: orderFormData.orderType.length === 1 ? orderFormData.orderType[0] : orderFormData.orderType,
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction.length === 1 ? orderFormData.fileAction[0] : orderFormData.fileAction,
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle specific error cases
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("jobId")) {
//           toast({
//             title: "Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           // Focus on the jobId field
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           // Focus on the assemblyId field
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//         } else {
//           toast({
//             title: "Duplicate Entry",
//             description: "One or more fields already exist. Please check your input values.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         // Generic error handling
//         toast({
//           title: "Submission Error",
//           description: error.message || "Failed to save MPI. Please try again.",
//           variant: "destructive",
//         })
//       }
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//               {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     return (
//       formData.jobId.trim() &&
//       formData.assemblyId.trim() &&
//       !validateJobId(formData.jobId) &&
//       !validateAssemblyId(formData.assemblyId) &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Station Selection
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${
//                                 formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${
//                                 formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>
//                       </div>

//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>

//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">
//                                     Configure quality control checklist items. Items marked as "Required" will be
//                                     included in the MPI.
//                                   </p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {/* Station Selection Dropdown */}
//                       <div className="space-y-3">
//                         <Label>Select Stations (Multiple Selection)</Label>
//                         {loadingStations ? (
//                           <div className="flex items-center gap-2">
//                             <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                             <span className="text-sm text-muted-foreground">Loading stations...</span>
//                           </div>
//                         ) : availableStations.length === 0 ? (
//                           <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                             <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                           </div>
//                         ) : (
//                           <div className="space-y-4">
//                             {/* Multi-select dropdown simulation using checkboxes */}
//                             <div className="border rounded-lg p-4 max-h-60 overflow-y-auto">
//                               <div className="space-y-3">
//                                 {availableStations.map((station) => (
//                                   <div key={station.id} className="flex items-center space-x-3">
//                                     <Checkbox
//                                       id={`station-select-${station.id}`}
//                                       checked={formData.selectedStationIds.includes(station.id)}
//                                       onCheckedChange={(checked) => {
//                                         if (checked) {
//                                           handleStationSelectionChange([...formData.selectedStationIds, station.id])
//                                         } else {
//                                           handleStationSelectionChange(
//                                             formData.selectedStationIds.filter((id) => id !== station.id),
//                                           )
//                                         }
//                                       }}
//                                     />
//                                     <div className="flex-1">
//                                       <Label
//                                         htmlFor={`station-select-${station.id}`}
//                                         className="cursor-pointer font-medium text-sm"
//                                       >
//                                         {station.stationName}
//                                       </Label>
//                                       <p className="text-xs text-muted-foreground">
//                                         ID: {station.stationId} • Location: {station.location}
//                                         {station.specifications && station.specifications.length > 0 && (
//                                           <span className="ml-2">• {station.specifications.length} specifications</span>
//                                         )}
//                                       </p>
//                                     </div>
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>

//                             {/* Selected Stations Summary */}
//                             {formData.selectedStationIds.length > 0 && (
//                               <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
//                                 <h4 className="font-medium text-blue-800 mb-3">
//                                   Selected Stations ({formData.selectedStationIds.length})
//                                 </h4>
//                                 <div className="flex flex-wrap gap-2">
//                                   {selectedStations.map((station) => (
//                                     <Badge key={station.id} variant="outline" className="bg-white">
//                                       {station.stationName}
//                                       {station.specifications && station.specifications.length > 0 && (
//                                         <span className="ml-1 text-xs">({station.specifications.length} specs)</span>
//                                       )}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         )}
//                       </div>

//                       {/* Station Specifications */}
//                       {selectedStations.length > 0 && (
//                         <div className="space-y-6">
//                           <div className="border-t pt-6">
//                             <h4 className="font-medium text-lg mb-4">Station Specifications</h4>
//                             <Accordion type="multiple" className="w-full space-y-4">
//                               {selectedStations.map((station) => (
//                                 <AccordionItem key={station.id} value={station.id} className="border rounded-lg">
//                                   <AccordionTrigger className="px-4 py-3 hover:no-underline">
//                                     <div className="flex items-center gap-3 w-full">
//                                       <Factory className="w-5 h-5 text-purple-600" />
//                                       <div className="flex-1 text-left">
//                                         <div className="flex items-center gap-2">
//                                           <span className="font-medium text-lg">{station.stationName}</span>
//                                           <Badge variant="outline">{station.stationId}</Badge>
//                                           <Badge variant="secondary">{station.status}</Badge>
//                                         </div>
//                                         <p className="text-sm text-muted-foreground mt-1">
//                                           Location: {station.location}
//                                           {station.operator && ` • Operator: ${station.operator}`}
//                                           {station.specifications && station.specifications.length > 0 && (
//                                             <span className="ml-2">
//                                               • {station.specifications.length} specifications
//                                             </span>
//                                           )}
//                                         </p>
//                                       </div>
//                                     </div>
//                                   </AccordionTrigger>
//                                   <AccordionContent className="px-4 pb-4">
//                                     <div className="border-t pt-4">
//                                       {station.specifications && station.specifications.length > 0 ? (
//                                         <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
//                                           {station.specifications.map((spec) => (
//                                             <div key={spec.id} className="space-y-3 p-4 bg-gray-50 rounded-lg border">
//                                               {renderSpecificationInput(spec, station.id)}
//                                             </div>
//                                           ))}
//                                         </div>
//                                       ) : (
//                                         <div className="text-center py-8">
//                                           <p className="text-muted-foreground">
//                                             No specifications available for this station.
//                                           </p>
//                                         </div>
//                                       )}
//                                     </div>
//                                   </AccordionContent>
//                                 </AccordionItem>
//                               ))}
//                             </Accordion>
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }






// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validate Job ID
//     const jobIdError = validateJobId(formData.jobId)
//     if (jobIdError) {
//       toast({
//         title: "Validation Error",
//         description: jobIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Validate Assembly ID
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     if (assemblyIdError) {
//       toast({
//         title: "Validation Error",
//         description: assemblyIdError,
//         variant: "destructive",
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           orderType: orderFormData.orderType.length === 1 ? orderFormData.orderType[0] : orderFormData.orderType,
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction.length === 1 ? orderFormData.fileAction[0] : orderFormData.fileAction,
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle specific error cases
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("jobId")) {
//           toast({
//             title: "Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           // Focus on the jobId field
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           // Focus on the assemblyId field
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//         } else {
//           toast({
//             title: "Duplicate Entry",
//             description: "One or more fields already exist. Please check your input values.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         // Generic error handling
//         toast({
//           title: "Submission Error",
//           description: error.message || "Failed to save MPI. Please try again.",
//           variant: "destructive",
//         })
//       }
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//               {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     return (
//       formData.jobId.trim() &&
//       formData.assemblyId.trim() &&
//       !validateJobId(formData.jobId) &&
//       !validateAssemblyId(formData.assemblyId) &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Instructions
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${
//                                 formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${
//                                 formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>
//                       </div>

//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>

//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">
//                                     Configure quality control checklist items. Items marked as "Required" will be
//                                     included in the MPI.
//                                   </p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {loadingStations ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading stations...</p>
//                           </div>
//                         </div>
//                       ) : availableStations.length === 0 ? (
//                         <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                           <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                         </div>
//                       ) : (
//                         <div className="flex gap-6 min-h-[600px]">
//                           {/* Left Sidebar - Station List */}
//                           <div className="w-1/4 border rounded-lg bg-gray-50">
//                             <div className="p-3 border-b bg-white rounded-t-lg">
//                               <h4 className="font-medium text-base">Stations</h4>
//                               <p className="text-xs text-muted-foreground">Click to select</p>
//                             </div>
//                             <div className="p-2 overflow-y-auto h-[530px]">
//                               <div className="space-y-1">
//                                 {availableStations.map((station) => (
//                                   <div
//                                     key={station.id}
//                                     className={`p-2 rounded cursor-pointer transition-all text-sm ${
//                                       formData.selectedStationIds.includes(station.id)
//                                         ? "bg-blue-100 text-blue-900 font-medium"
//                                         : "bg-white hover:bg-gray-100"
//                                     }`}
//                                     onClick={() => {
//                                       // Only allow single selection
//                                       if (formData.selectedStationIds.includes(station.id)) {
//                                         handleStationSelectionChange([]) // Deselect if already selected
//                                       } else {
//                                         handleStationSelectionChange([station.id]) // Select only this station
//                                       }
//                                     }}
//                                   >
//                                     {station.stationName}
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>
//                           </div>

//                           {/* Right Panel - Station Specifications */}
//                           <div className="flex-1 border rounded-lg bg-gray-50">
//                             {formData.selectedStationIds.length === 0 ? (
//                               <div className="flex items-center justify-center h-full">
//                                 <div className="text-center">
//                                   <Factory className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//                                   <h4 className="font-medium text-gray-600 mb-2">No Station Selected</h4>
//                                   <p className="text-sm text-muted-foreground">
//                                     Select a station from the left sidebar to view its specifications
//                                   </p>
//                                 </div>
//                               </div>
//                             ) : (
//                               <div className="h-full flex flex-col">

//                                 <div className="flex-1 overflow-hidden p-4">
//                                   {selectedStations[0] && (
//                                     <div className="p-1">
//                                       <div className="flex items-center gap-3 mb-4">
//                                         <Factory className="w-5 h-5 text-purple-600" />
//                                         <div className="flex-1">
//                                           <div className="flex items-center gap-2">
//                                             <span className="font-medium text-lg">
//                                               {selectedStations[0].stationName} Specifications
//                                             </span>
//                                           </div>

//                                         </div>
//                                       </div>

//                                       {selectedStations[0].specifications &&
//                                       selectedStations[0].specifications.length > 0 ? (
//                                         <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                                           {selectedStations[0].specifications.map((spec) => (
//                                             <div key={spec.id} className="space-y-3 p-3 bg-white rounded border">
//                                               {renderSpecificationInput(spec, selectedStations[0].id)}
//                                             </div>
//                                           ))}
//                                         </div>
//                                       ) : (
//                                         <div className="text-center py-6">
//                                           <p className="text-muted-foreground">
//                                             No specifications available for this station.
//                                           </p>
//                                         </div>
//                                       )}
//                                     </div>
//                                   )}
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }






















// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       // Extract document control IDs from order forms
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null // Optional field
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Refresh existing IDs before validation to ensure we have the latest data
//     await loadExistingIds()

//     // Comprehensive validation - prevent submission if ANY ID is duplicate
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     // Collect all validation errors
//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // CRITICAL: If there are ANY validation errors, show them all and COMPLETELY PREVENT submission
//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000, // Show longer for critical errors
//       })
//       setActiveTab("basic-info")
//       return // COMPLETELY STOP EXECUTION - NO MPI CREATION ATTEMPT
//     }

//     // Additional safety check - double-check all IDs one more time
//     const finalJobIdCheck = existingJobIds.includes(formData.jobId.toLowerCase())
//     const finalAssemblyIdCheck = existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const finalDocControlIdCheck = orderFormData.documentControlId
//       ? existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())
//       : false

//     if (finalJobIdCheck || finalAssemblyIdCheck || finalDocControlIdCheck) {
//       const duplicateIds = []
//       if (finalJobIdCheck) duplicateIds.push(`Job ID: ${formData.jobId}`)
//       if (finalAssemblyIdCheck) duplicateIds.push(`Assembly ID: ${formData.assemblyId}`)
//       if (finalDocControlIdCheck) duplicateIds.push(`Document Control ID: ${orderFormData.documentControlId}`)

//       toast({
//         title: "🚫 CRITICAL: Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold text-red-800">The following IDs already exist in the system:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {duplicateIds.map((id, index) => (
//                 <li key={index} className="text-sm font-medium text-red-700">
//                   {id}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-bold text-red-800">
//               MPI creation has been completely blocked to prevent database errors.
//             </p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 12000,
//       })
//       setActiveTab("basic-info")
//       return // ABSOLUTELY NO SUBMISSION ALLOWED
//     }

//     // Validate enum values before submission
//     const validateEnumValues = () => {
//       if (orderFormData.orderType.length > 0) {
//         const validOrderTypes = enums.orderTypes || []
//         const invalidOrderTypes = orderFormData.orderType.filter((type) => !validOrderTypes.includes(type))
//         if (invalidOrderTypes.length > 0) {
//           toast({
//             title: "Invalid Order Type",
//             description: `Invalid order type(s): ${invalidOrderTypes.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       if (orderFormData.fileAction.length > 0) {
//         const validFileActions = enums.fileActions || []
//         const invalidFileActions = orderFormData.fileAction.filter((action) => !validFileActions.includes(action))
//         if (invalidFileActions.length > 0) {
//           toast({
//             title: "Invalid File Action",
//             description: `Invalid file action(s): ${invalidFileActions.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       return true
//     }

//     // Validate enums
//     if (!validateEnumValues()) {
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           // Ensure orderType values match the Prisma enum exactly
//           orderType: orderFormData.orderType, // Always send as array
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction, // Always send as array
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)

//       // If we reach here, the submission was successful
//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle partial success scenarios
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. The MPI creation has been blocked to prevent database errors. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           // Focus on the documentControlId field
//           const docControlInput = document.getElementById("documentControlId")
//           if (docControlInput) {
//             docControlInput.focus()
//           }
//           // Refresh the existing IDs to get the latest data
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         }
//       }

//       // Handle Prisma validation errors
//       if (error.message?.includes("PrismaClientValidationError")) {
//         if (error.message?.includes("orderType")) {
//           toast({
//             title: "Invalid Order Type",
//             description: "The selected order type is not valid. Please check your selection and try again.",
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return
//         }
//       }

//       // Generic error handling with better messaging
//       toast({
//         title: "❌ Submission Error",
//         description: error.message?.includes("MPI")
//           ? "There was an issue creating the MPI. Please check if it was created and try again if needed."
//           : error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//             {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//               {spec.required && <p className="text-xs text-red-600">* This field is required</p>}
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     // Additional safety checks
//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Instructions
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${
//                                 formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${
//                                 formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className={`h-11 ${
//                               orderFormData.documentControlId &&
//                               validateDocumentControlId(orderFormData.documentControlId)
//                                 ? "border-red-500"
//                                 : orderFormData.documentControlId &&
//                                     !validateDocumentControlId(orderFormData.documentControlId)
//                                   ? "border-green-500"
//                                   : ""
//                             }`}
//                           />
//                           {orderFormData.documentControlId &&
//                             validateDocumentControlId(orderFormData.documentControlId) && (
//                               <p className="text-sm text-red-500">
//                                 {validateDocumentControlId(orderFormData.documentControlId)}
//                               </p>
//                             )}
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>
//                       </div>

//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>

//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">
//                                     Configure quality control checklist items. Items marked as "Required" will be
//                                     included in the MPI.
//                                   </p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {loadingStations ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading stations...</p>
//                           </div>
//                         </div>
//                       ) : availableStations.length === 0 ? (
//                         <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                           <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                         </div>
//                       ) : (
//                         <div className="flex gap-6 min-h-[600px]">
//                           {/* Left Sidebar - Station List */}
//                           <div className="w-1/4 border rounded-lg bg-gray-50">
//                             <div className="p-3 border-b bg-white rounded-t-lg">
//                               <h4 className="font-medium text-base">Stations</h4>
//                               <p className="text-xs text-muted-foreground">Click to select</p>
//                             </div>
//                             <div className="p-2 overflow-y-auto h-[530px]">
//                               <div className="space-y-1">
//                                 {availableStations.map((station) => (
//                                   <div
//                                     key={station.id}
//                                     className={`p-2 rounded cursor-pointer transition-all text-sm ${
//                                       formData.selectedStationIds.includes(station.id)
//                                         ? "bg-blue-100 text-blue-900 font-medium"
//                                         : "bg-white hover:bg-gray-100"
//                                     }`}
//                                     onClick={() => {
//                                       // Only allow single selection
//                                       if (formData.selectedStationIds.includes(station.id)) {
//                                         handleStationSelectionChange([]) // Deselect if already selected
//                                       } else {
//                                         handleStationSelectionChange([station.id]) // Select only this station
//                                       }
//                                     }}
//                                   >
//                                     {station.stationName}
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>
//                           </div>

//                           {/* Right Panel - Station Specifications */}
//                           <div className="flex-1 border rounded-lg bg-gray-50">
//                             {formData.selectedStationIds.length === 0 ? (
//                               <div className="flex items-center justify-center h-full">
//                                 <div className="text-center">
//                                   <Factory className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//                                   <h4 className="font-medium text-gray-600 mb-2">No Station Selected</h4>
//                                   <p className="text-sm text-muted-foreground">
//                                     Select a station from the left sidebar to view its specifications
//                                   </p>
//                                 </div>
//                               </div>
//                             ) : (
//                               <div className="h-full flex flex-col">
//                                 <div className="flex-1 overflow-hidden p-4">
//                                   {selectedStations[0] && (
//                                     <div className="p-1">
//                                       <div className="flex items-center gap-3 mb-4">
//                                         <Factory className="w-5 h-5 text-purple-600" />
//                                         <div className="flex-1">
//                                           <div className="flex items-center gap-2">
//                                             <span className="font-medium text-lg">
//                                               {selectedStations[0].stationName} Specifications
//                                             </span>
//                                           </div>
//                                         </div>
//                                       </div>

//                                       {selectedStations[0].specifications &&
//                                       selectedStations[0].specifications.length > 0 ? (
//                                         <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                                           {selectedStations[0].specifications.map((spec) => (
//                                             <div key={spec.id} className="space-y-3 p-3 bg-white rounded border">
//                                               {renderSpecificationInput(spec, selectedStations[0].id)}
//                                             </div>
//                                           ))}
//                                         </div>
//                                       ) : (
//                                         <div className="text-center py-6">
//                                           <p className="text-muted-foreground">
//                                             No specifications available for this station.
//                                           </p>
//                                         </div>
//                                       )}
//                                     </div>
//                                   )}
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : !isFormValid() ? (
//                     <>Fix Validation Errors</>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }






















// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       // Extract document control IDs from order forms
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null // Optional field
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Refresh existing IDs before validation to ensure we have the latest data
//     await loadExistingIds()

//     // Comprehensive validation - prevent submission if ANY ID is duplicate
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     // Collect all validation errors
//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // CRITICAL: If there are ANY validation errors, show them all and COMPLETELY PREVENT submission
//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000, // Show longer for critical errors
//       })
//       setActiveTab("basic-info")
//       return // COMPLETELY STOP EXECUTION - NO MPI CREATION ATTEMPT
//     }

//     // Additional safety check - double-check all IDs one more time
//     const finalJobIdCheck = existingJobIds.includes(formData.jobId.toLowerCase())
//     const finalAssemblyIdCheck = existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const finalDocControlIdCheck = orderFormData.documentControlId
//       ? existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())
//       : false

//     if (finalJobIdCheck || finalAssemblyIdCheck || finalDocControlIdCheck) {
//       const duplicateIds = []
//       if (finalJobIdCheck) duplicateIds.push(`Job ID: ${formData.jobId}`)
//       if (finalAssemblyIdCheck) duplicateIds.push(`Assembly ID: ${formData.assemblyId}`)
//       if (finalDocControlIdCheck) duplicateIds.push(`Document Control ID: ${orderFormData.documentControlId}`)

//       toast({
//         title: "🚫 CRITICAL: Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold text-red-800">The following IDs already exist in the system:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {duplicateIds.map((id, index) => (
//                 <li key={index} className="text-sm font-medium text-red-700">
//                   {id}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-bold text-red-800">
//               MPI creation has been completely blocked to prevent database errors.
//             </p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 12000,
//       })
//       setActiveTab("basic-info")
//       return // ABSOLUTELY NO SUBMISSION ALLOWED
//     }

//     // Validate enum values before submission
//     const validateEnumValues = () => {
//       if (orderFormData.orderType.length > 0) {
//         const validOrderTypes = enums.orderTypes || []
//         const invalidOrderTypes = orderFormData.orderType.filter((type) => !validOrderTypes.includes(type))
//         if (invalidOrderTypes.length > 0) {
//           toast({
//             title: "Invalid Order Type",
//             description: `Invalid order type(s): ${invalidOrderTypes.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       if (orderFormData.fileAction.length > 0) {
//         const validFileActions = enums.fileActions || []
//         const invalidFileActions = orderFormData.fileAction.filter((action) => !validFileActions.includes(action))
//         if (invalidFileActions.length > 0) {
//           toast({
//             title: "Invalid File Action",
//             description: `Invalid file action(s): ${invalidFileActions.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       return true
//     }

//     // Validate enums
//     if (!validateEnumValues()) {
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//           .map((section) => {
//             // Include items that are either modified OR have required=true
//             const itemsToInclude = (section.items || [])
//               .filter((item) => {
//                 const modifications = checklistModifications[item.id]
//                 const currentRequired = modifications?.required ?? item.required
//                 const currentRemarks = modifications?.remarks ?? item.remarks

//                 // Include if required is true OR if it has been modified
//                 return (
//                   currentRequired ||
//                   (modifications &&
//                     (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                 )
//               })
//               .map((item) => {
//                 const modifications = checklistModifications[item.id]
//                 return {
//                   description: item.description,
//                   required: modifications?.required ?? item.required,
//                   remarks: modifications?.remarks ?? item.remarks,
//                   createdBy: item.createdBy || "System",
//                   isActive: item.isActive !== undefined ? item.isActive : true,
//                   category: item.category || section.name,
//                 }
//               })

//             // Only return section if it has items to include
//             return itemsToInclude.length > 0
//               ? {
//                 name: section.name,
//                 checklistItems: itemsToInclude,
//               }
//               : null
//           })
//           .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           // Ensure orderType values match the Prisma enum exactly
//           orderType: orderFormData.orderType, // Always send as array
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction, // Always send as array
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)

//       // If we reach here, the submission was successful
//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle partial success scenarios
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. The MPI creation has been blocked to prevent database errors. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           // Focus on the documentControlId field
//           const docControlInput = document.getElementById("documentControlId")
//           if (docControlInput) {
//             docControlInput.focus()
//           }
//           // Refresh the existing IDs to get the latest data
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         }
//       }

//       // Handle Prisma validation errors
//       if (error.message?.includes("PrismaClientValidationError")) {
//         if (error.message?.includes("orderType")) {
//           toast({
//             title: "Invalid Order Type",
//             description: "The selected order type is not valid. Please check your selection and try again.",
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return
//         }
//       }

//       // Generic error handling with better messaging
//       toast({
//         title: "❌ Submission Error",
//         description: error.message?.includes("MPI")
//           ? "There was an issue creating the MPI. Please check if it was created and try again if needed."
//           : error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   // Set a temporary value to indicate "Other" is selected
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {/* Show input field when "Other" is selected */}
//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     // Additional safety checks
//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-3">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Instructions
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                                 }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                                 }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className={`h-11 ${orderFormData.documentControlId &&
//                                 validateDocumentControlId(orderFormData.documentControlId)
//                                 ? "border-red-500"
//                                 : orderFormData.documentControlId &&
//                                   !validateDocumentControlId(orderFormData.documentControlId)
//                                   ? "border-green-500"
//                                   : ""
//                               }`}
//                           />
//                           {orderFormData.documentControlId &&
//                             validateDocumentControlId(orderFormData.documentControlId) && (
//                               <p className="text-sm text-red-500">
//                                 {validateDocumentControlId(orderFormData.documentControlId)}
//                               </p>
//                             )}
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>
//                       </div>

//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>

//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">
//                                     Configure quality control checklist items. Items marked as "Required" will be
//                                     included in the MPI.
//                                   </p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {loadingStations ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading stations...</p>
//                           </div>
//                         </div>
//                       ) : availableStations.length === 0 ? (
//                         <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                           <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                         </div>
//                       ) : (
//                         <div className="flex gap-6 min-h-[600px]">
//                           {/* Left Sidebar - Station List */}
//                           <div className="w-1/4 border rounded-lg bg-gray-50">
//                             <div className="p-3 border-b bg-white rounded-t-lg">
//                               <h4 className="font-medium text-base">Stations</h4>
//                               <p className="text-xs text-muted-foreground">
//                                 {formData.selectedStationIds.length > 0
//                                   ? `${formData.selectedStationIds.length} selected`
//                                   : "Click to select multiple"}
//                               </p>
//                             </div>
//                             <div className="p-2 overflow-y-auto h-[530px]">
//                               <div className="space-y-1">
//                                 {availableStations.map((station) => (
//                                   <div
//                                     key={station.id}
//                                     className={`p-2 rounded cursor-pointer transition-all text-sm border-2 ${formData.selectedStationIds.includes(station.id)
//                                         ? "bg-blue-100 text-blue-900 border-blue-300"
//                                         : "bg-white hover:bg-gray-100 border-transparent"
//                                       } ${activeStationId === station.id ? "ring-2 ring-purple-400 ring-offset-1" : ""}`}
//                                     onClick={() => {
//                                       // Set as active station for viewing specifications
//                                       setActiveStationId(station.id)

//                                       // Handle selection/deselection
//                                       if (formData.selectedStationIds.includes(station.id)) {
//                                         // Remove from selection
//                                         handleStationSelectionChange(
//                                           formData.selectedStationIds.filter((id) => id !== station.id),
//                                         )
//                                       } else {
//                                         // Add to selection
//                                         handleStationSelectionChange([...formData.selectedStationIds, station.id])
//                                       }
//                                     }}
//                                   >
//                                     {station.stationName}
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>
//                           </div>

//                           {/* Right Panel - Station Specifications */}
//                           <div className="flex-1 border rounded-lg bg-white">
//                             {activeStationId ? (
//                               <div className="h-full flex flex-col">
//                                 <div className="p-4 border-b bg-white rounded-t-lg">
//                                   <h4 className="font-medium text-lg">
//                                     {availableStations.find((s) => s.id === activeStationId)?.stationName} Station Specifications
//                                   </h4>

//                                 </div>
//                                 <div className="flex-1 overflow-y-auto p-4">
//                                   {(() => {
//                                     const activeStation = availableStations.find((s) => s.id === activeStationId)
//                                     if (!activeStation) return null

//                                     return (
//                                       <div >


//                                         {activeStation.specifications && activeStation.specifications.length > 0 ? (
//                                           <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                                             {activeStation.specifications.map((spec) => (
//                                               <div key={spec.id} className="space-y-3 p-3 bg-gray-50 rounded border">

//                                                 {renderSpecificationInput(spec, activeStation.id)}
//                                               </div>
//                                             ))}
//                                           </div>
//                                         ) : (
//                                           <div className="text-center py-6 bg-gray-50 rounded border-2 border-dashed">
//                                             <p className="text-muted-foreground">
//                                               No specifications available for this station.
//                                             </p>
//                                           </div>
//                                         )}
//                                       </div>
//                                     )
//                                   })()}
//                                 </div>
//                               </div>
//                             ) : (
//                               <div className="flex items-center justify-center h-full">
//                                 <div className="text-center">
//                                   <Factory className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//                                   <h4 className="font-medium text-gray-600 mb-2">No Station Active</h4>
//                                   <p className="text-sm text-muted-foreground">
//                                     Click on a station from the left sidebar to view its specifications
//                                     {formData.selectedStationIds.length > 0 && (
//                                       <span className="block mt-2 text-blue-600 font-medium">
//                                         {formData.selectedStationIds.length} station
//                                         {formData.selectedStationIds.length > 1 ? "s" : ""} selected for MPI
//                                       </span>
//                                     )}
//                                   </p>
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>

//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }












// "use client"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { Badge } from "@/components/ui/badge"
// import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
// import { Textarea } from "@/components/ui/textarea"
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
// import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
// import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
// import { ArrowLeft, Factory, Info, ClipboardList, FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIDocumentationAPI } from "./mpi-document-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   fileUrl: string
//   description: string
//   fileName?: string
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       // Extract document control IDs from order forms
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // For now, we'll simulate the upload since we don't have an MPI ID yet
//       // In a real scenario, you might want to upload after MPI creation or use a temporary storage
//       const result = await MPIDocumentationAPI.uploadDocument("temp-mpi-id", file, description)

//       const newDoc: MPIDocumentation = {
//         fileUrl: result.fileUrl,
//         description: description,
//         fileName: file.name,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "MPI document uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("MPI document upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload MPI document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null // Optional field
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Refresh existing IDs before validation to ensure we have the latest data
//     await loadExistingIds()

//     // Comprehensive validation - prevent submission if ANY ID is duplicate
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     // Collect all validation errors
//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // CRITICAL: If there are ANY validation errors, show them all and COMPLETELY PREVENT submission
//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000, // Show longer for critical errors
//       })
//       setActiveTab("basic-info")
//       return // COMPLETELY STOP EXECUTION - NO MPI CREATION ATTEMPT
//     }

//     // Additional safety check - double-check all IDs one more time
//     const finalJobIdCheck = existingJobIds.includes(formData.jobId.toLowerCase())
//     const finalAssemblyIdCheck = existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const finalDocControlIdCheck = orderFormData.documentControlId
//       ? existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())
//       : false

//     if (finalJobIdCheck || finalAssemblyIdCheck || finalDocControlIdCheck) {
//       const duplicateIds = []
//       if (finalJobIdCheck) duplicateIds.push(`Job ID: ${formData.jobId}`)
//       if (finalAssemblyIdCheck) duplicateIds.push(`Assembly ID: ${formData.assemblyId}`)
//       if (finalDocControlIdCheck) duplicateIds.push(`Document Control ID: ${orderFormData.documentControlId}`)

//       toast({
//         title: "🚫 CRITICAL: Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold text-red-800">The following IDs already exist in the system:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {duplicateIds.map((id, index) => (
//                 <li key={index} className="text-sm font-medium text-red-700">
//                   {id}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-bold text-red-800">
//               MPI creation has been completely blocked to prevent database errors.
//             </p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 12000,
//       })
//       setActiveTab("basic-info")
//       return // ABSOLUTELY NO SUBMISSION ALLOWED
//     }

//     // Validate enum values before submission
//     const validateEnumValues = () => {
//       if (orderFormData.orderType.length > 0) {
//         const validOrderTypes = enums.orderTypes || []
//         const invalidOrderTypes = orderFormData.orderType.filter((type) => !validOrderTypes.includes(type))
//         if (invalidOrderTypes.length > 0) {
//           toast({
//             title: "Invalid Order Type",
//             description: `Invalid order type(s): ${invalidOrderTypes.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       if (orderFormData.fileAction.length > 0) {
//         const validFileActions = enums.fileActions || []
//         const invalidFileActions = orderFormData.fileAction.filter((action) => !validFileActions.includes(action))
//         if (invalidFileActions.length > 0) {
//           toast({
//             title: "Invalid File Action",
//             description: `Invalid file action(s): ${invalidFileActions.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       return true
//     }

//     // Validate enums
//     if (!validateEnumValues()) {
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       ...(mpiDocumentation.length > 0 && {
//         mpiDocumentation: mpiDocumentation.map((doc) => ({
//           fileUrl: doc.fileUrl,
//           description: doc.description,
//         })),
//       }),
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           // Ensure orderType values match the Prisma enum exactly
//           orderType: orderFormData.orderType, // Always send as array
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction, // Always send as array
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       await onSubmit(submitData as CreateMPIDto)

//       // If we reach here, the submission was successful
//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle partial success scenarios
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. The MPI creation has been blocked to prevent database errors. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           // Focus on the documentControlId field
//           const docControlInput = document.getElementById("documentControlId")
//           if (docControlInput) {
//             docControlInput.focus()
//           }
//           // Refresh the existing IDs to get the latest data
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         }
//       }

//       // Handle Prisma validation errors
//       if (error.message?.includes("PrismaClientValidationError")) {
//         if (error.message?.includes("orderType")) {
//           toast({
//             title: "Invalid Order Type",
//             description: "The selected order type is not valid. Please check your selection and try again.",
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return
//         }
//       }

//       // Generic error handling with better messaging
//       toast({
//         title: "❌ Submission Error",
//         description: error.message?.includes("MPI")
//           ? "There was an issue creating the MPI. Please check if it was created and try again if needed."
//           : error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const getInputTypeColor = (inputType: string) => {
//     const colors: Record<string, string> = {
//       TEXT: "bg-blue-100 text-blue-800 border-blue-200",
//       number: "bg-green-100 text-green-800 border-green-200",
//       CHECKBOX: "bg-pink-100 text-pink-800 border-pink-200",
//       DROPDOWN: "bg-orange-100 text-orange-800 border-orange-200",
//       FILE_UPLOAD: "bg-purple-100 text-purple-800 border-purple-200",
//     }
//     return colors[inputType] || "bg-gray-100 text-gray-800 border-gray-200"
//   }

//   const formatInputType = (inputType: string) => {
//     return inputType
//       .replace("_", " ")
//       .toLowerCase()
//       .replace(/\b\w/g, (l) => l.toUpperCase())
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   // Set a temporary value to indicate "Other" is selected
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {/* Show input field when "Other" is selected */}
//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     // Additional safety checks
//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <div className="flex items-center justify-between w-full">
//           <div>
//             <h1 className="text-3xl font-bold text-red-600">Create MPI</h1>
//           </div>
//           <Button variant="outline" size="sm" onClick={onCancel}>
//             <ArrowLeft className="w-4 h-4 mr-2" />
//             Back
//           </Button>
//         </div>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
//                 <TabsList className="grid w-full grid-cols-4">
//                   <TabsTrigger value="basic-info" className="flex items-center gap-2">
//                     <Info className="w-4 h-4" />
//                     Order Details
//                   </TabsTrigger>
//                   <TabsTrigger value="documentation" className="flex items-center gap-2">
//                     <FileText className="w-4 h-4" />
//                     Documentation
//                     {mpiDocumentation.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {mpiDocumentation.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="checklist" className="flex items-center gap-2">
//                     <ClipboardList className="w-4 h-4" />
//                     Checklist
//                     {checklistTemplate.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {checklistTemplate.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                   <TabsTrigger value="stations" className="flex items-center gap-2">
//                     <Factory className="w-4 h-4" />
//                     Instructions
//                     {selectedStations.length > 0 && (
//                       <Badge variant="secondary" size="sm" className="ml-1">
//                         {selectedStations.length}
//                       </Badge>
//                     )}
//                   </TabsTrigger>
//                 </TabsList>

//                 {/* Basic Information & Order Form Tab */}
//                 <TabsContent value="basic-info" className="space-y-6 mt-6">
//                   {/* MPI Basic Information */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="jobId">Job ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="jobId"
//                               value={formData.jobId}
//                               onChange={(e) => handleChange("jobId", e.target.value)}
//                               placeholder="Enter job ID (e.g., JOB-2025-0010)"
//                               required
//                               className={`h-11 ${
//                                 formData.jobId && validateJobId(formData.jobId)
//                                   ? "border-red-500"
//                                   : formData.jobId && !validateJobId(formData.jobId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.jobId && validateJobId(formData.jobId) && (
//                             <p className="text-sm text-red-500">{validateJobId(formData.jobId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="assemblyId">Assembly ID *</Label>
//                           <div className="relative">
//                             <Input
//                               id="assemblyId"
//                               value={formData.assemblyId}
//                               onChange={(e) => handleChange("assemblyId", e.target.value)}
//                               placeholder="Enter assembly ID (e.g., ASM-2025-1010)"
//                               required
//                               className={`h-11 ${
//                                 formData.assemblyId && validateAssemblyId(formData.assemblyId)
//                                   ? "border-red-500"
//                                   : formData.assemblyId && !validateAssemblyId(formData.assemblyId)
//                                     ? "border-green-500"
//                                     : ""
//                               }`}
//                             />
//                             {checkingIds && (
//                               <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
//                                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               </div>
//                             )}
//                           </div>
//                           {formData.assemblyId && validateAssemblyId(formData.assemblyId) && (
//                             <p className="text-sm text-red-500">{validateAssemblyId(formData.assemblyId)}</p>
//                           )}
//                         </div>
//                         <div className="space-y-2">
//                           <Label htmlFor="customer">Customer</Label>
//                           <Input
//                             id="customer"
//                             value={formData.customer}
//                             onChange={(e) => handleChange("customer", e.target.value)}
//                             placeholder="Enter customer name (optional)"
//                             className="h-11"
//                           />
//                         </div>
//                       </div>
//                     </CardContent>
//                   </Card>

//                   {/* Order Forms Section */}
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
//                         <div className="space-y-2">
//                           <Label htmlFor="internalOrderNumber">Internal Order Number</Label>
//                           <Input
//                             id="internalOrderNumber"
//                             value={orderFormData.internalOrderNumber}
//                             onChange={(e) => handleOrderFormChange("internalOrderNumber", e.target.value)}
//                             placeholder="Enter internal order number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="revision">Revision</Label>
//                           <Input
//                             id="revision"
//                             value={orderFormData.revision}
//                             onChange={(e) => handleOrderFormChange("revision", e.target.value)}
//                             placeholder="Enter revision number"
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="documentControlId">Document Control ID</Label>
//                           <Input
//                             id="documentControlId"
//                             value={orderFormData.documentControlId}
//                             onChange={(e) => handleOrderFormChange("documentControlId", e.target.value)}
//                             placeholder="Enter document control ID"
//                             className={`h-11 ${
//                               orderFormData.documentControlId &&
//                               validateDocumentControlId(orderFormData.documentControlId)
//                                 ? "border-red-500"
//                                 : orderFormData.documentControlId &&
//                                     !validateDocumentControlId(orderFormData.documentControlId)
//                                   ? "border-green-500"
//                                   : ""
//                             }`}
//                           />
//                           {orderFormData.documentControlId &&
//                             validateDocumentControlId(orderFormData.documentControlId) && (
//                               <p className="text-sm text-red-500">
//                                 {validateDocumentControlId(orderFormData.documentControlId)}
//                               </p>
//                             )}
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="distributionDate">Distribution Date</Label>
//                           <Input
//                             id="distributionDate"
//                             type="date"
//                             value={orderFormData.distributionDate}
//                             onChange={(e) => handleOrderFormChange("distributionDate", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>

//                         <div className="space-y-2">
//                           <Label htmlFor="requiredBy">Required By</Label>
//                           <Input
//                             id="requiredBy"
//                             type="date"
//                             value={orderFormData.requiredBy}
//                             onChange={(e) => handleOrderFormChange("requiredBy", e.target.value)}
//                             className="h-11"
//                           />
//                         </div>
//                       </div>

//                       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-5">
//                         {/* Order Type */}
//                         <div className="space-y-3">
//                           <Label>Order Type </Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading order types...</span>
//                             </div>
//                           ) : enums.orderTypes && enums.orderTypes.length > 0 ? (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
//                                   {enums.orderTypes.map((type: string) => (
//                                     <div key={type} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`order-type-${type}`}
//                                         checked={orderFormData.orderType.includes(type)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("orderType", [...orderFormData.orderType, type])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "orderType",
//                                               orderFormData.orderType.filter((t) => t !== type),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`order-type-${type}`} className="cursor-pointer text-sm">
//                                         {type.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   ))}
//                                 </div>
//                               </div>

//                               {/* Selected badges */}
//                               {orderFormData.orderType.length > 0 && (
//                                 <div className="flex flex-wrap gap-2">
//                                   {orderFormData.orderType.map((type) => (
//                                     <Badge key={type} variant="outline" className="bg-blue-50">
//                                       {type.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           ) : (
//                             <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                               <p className="text-sm text-yellow-800">
//                                 Order types not available. Please check the enum endpoint.
//                               </p>
//                             </div>
//                           )}
//                         </div>

//                         {/* File Action */}
//                         <div className="space-y-2">
//                           <Label htmlFor="fileAction">File Action</Label>
//                           {loadingEnums ? (
//                             <div className="flex items-center gap-2">
//                               <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                               <span className="text-sm text-muted-foreground">Loading file actions...</span>
//                             </div>
//                           ) : (
//                             <div className="space-y-4">
//                               <div className="p-1">
//                                 <div className="space-y-3 max-h-40 overflow-y-auto">
//                                   {enums.fileActions?.map((action: string) => (
//                                     <div key={action} className="flex items-center space-x-3">
//                                       <Checkbox
//                                         id={`file-action-${action}`}
//                                         checked={orderFormData.fileAction.includes(action)}
//                                         onCheckedChange={(checked) => {
//                                           if (checked) {
//                                             handleOrderFormChange("fileAction", [...orderFormData.fileAction, action])
//                                           } else {
//                                             handleOrderFormChange(
//                                               "fileAction",
//                                               orderFormData.fileAction.filter((a) => a !== action),
//                                             )
//                                           }
//                                         }}
//                                       />
//                                       <Label htmlFor={`file-action-${action}`} className="cursor-pointer text-sm">
//                                         {action.replace(/_/g, " ")}
//                                       </Label>
//                                     </div>
//                                   )) || <p className="text-sm text-muted-foreground">No file actions available</p>}
//                                 </div>
//                               </div>
//                               {orderFormData.fileAction.length > 0 && (
//                                 <div className="flex flex-wrap gap-2 mt-2">
//                                   {orderFormData.fileAction.map((action) => (
//                                     <Badge key={action} variant="outline" className="bg-green-50">
//                                       {action.replace(/_/g, " ")}
//                                     </Badge>
//                                   ))}
//                                 </div>
//                               )}
//                             </div>
//                           )}
//                         </div>
//                       </div>

//                       <div className="space-y-2 mt-5">
//                         <Label htmlFor="otherAttachments">Other Attachments</Label>
//                         <Textarea
//                           id="otherAttachments"
//                           value={orderFormData.otherAttachments}
//                           onChange={(e) => handleOrderFormChange("otherAttachments", e.target.value)}
//                           placeholder="Describe any additional attachments or documents"
//                           rows={3}
//                         />
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Documentation Tab */}
//                 <TabsContent value="documentation" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       <div className="space-y-4">
//                         <div className="flex items-center justify-between">
//                           <div>
//                             <h3 className="text-lg font-medium">MPI Documentation</h3>
//                             <p className="text-sm text-muted-foreground">
//                               Upload general documents related to this MPI
//                             </p>
//                           </div>
//                           <Badge variant="outline" className="bg-blue-50">
//                             {mpiDocumentation.length} document{mpiDocumentation.length !== 1 ? "s" : ""}
//                           </Badge>
//                         </div>

//                         {/* Upload Section */}
//                         <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
//                           <div className="space-y-4">
//                             <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                               <div className="space-y-2">
//                                 <Label htmlFor="mpi-doc-file">Select Document</Label>
//                                 <Input
//                                   id="mpi-doc-file"
//                                   type="file"
//                                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                                   className="cursor-pointer"
//                                   disabled={uploadingMpiDoc}
//                                 />
//                               </div>
//                               <div className="space-y-2">
//                                 <Label htmlFor="mpi-doc-description">Description</Label>
//                                 <Input
//                                   id="mpi-doc-description"
//                                   placeholder="Enter document description"
//                                   disabled={uploadingMpiDoc}
//                                 />
//                               </div>
//                             </div>
//                             <Button
//                               type="button"
//                               variant="outline"
//                               disabled={uploadingMpiDoc}
//                               onClick={() => {
//                                 const fileInput = document.getElementById("mpi-doc-file") as HTMLInputElement
//                                 const descInput = document.getElementById("mpi-doc-description") as HTMLInputElement
//                                 const file = fileInput?.files?.[0]
//                                 const description = descInput?.value

//                                 if (file && description) {
//                                   handleMpiDocumentUpload(file, description)
//                                   // Clear inputs
//                                   fileInput.value = ""
//                                   descInput.value = ""
//                                 } else {
//                                   toast({
//                                     title: "Missing Information",
//                                     description: "Please select a file and enter a description.",
//                                     variant: "destructive",
//                                   })
//                                 }
//                               }}
//                               className="w-full"
//                             >
//                               {uploadingMpiDoc ? (
//                                 <div className="flex items-center gap-2">
//                                   <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                                   Uploading...
//                                 </div>
//                               ) : (
//                                 <>
//                                   <FileText className="w-4 h-4 mr-2" />
//                                   Upload Document
//                                 </>
//                               )}
//                             </Button>
//                           </div>
//                         </div>

//                         {/* Uploaded Documents List */}
//                         {mpiDocumentation.length > 0 && (
//                           <div className="space-y-3">
//                             <h4 className="font-medium text-sm">Uploaded Documents</h4>
//                             <div className="space-y-2">
//                               {mpiDocumentation.map((doc, index) => (
//                                 <div
//                                   key={index}
//                                   className="flex items-center justify-between p-3 bg-gray-50 rounded border"
//                                 >
//                                   <div className="flex items-center gap-3">
//                                     <FileText className="w-4 h-4 text-blue-600" />
//                                     <div>
//                                       <p className="text-sm font-medium">{doc.description}</p>
//                                       <p className="text-xs text-muted-foreground">{doc.fileName}</p>
//                                     </div>
//                                   </div>
//                                   <div className="flex items-center gap-2">
//                                     <Button
//                                       type="button"
//                                       size="sm"
//                                       variant="outline"
//                                       onClick={() => window.open(doc.fileUrl, "_blank")}
//                                     >
//                                       <Eye className="w-3 h-3 mr-1" />
//                                       View
//                                     </Button>
//                                     <Button
//                                       type="button"
//                                       size="sm"
//                                       variant="outline"
//                                       onClick={() => removeMpiDocument(index)}
//                                       className="text-red-600 hover:text-red-700"
//                                     >
//                                       Remove
//                                     </Button>
//                                   </div>
//                                 </div>
//                               ))}
//                             </div>
//                           </div>
//                         )}
//                       </div>
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Checklist Tab */}
//                 <TabsContent value="checklist" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="mt-5">
//                       {loadingChecklist ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading checklist template...</p>
//                           </div>
//                         </div>
//                       ) : checklistTemplate.length === 0 ? (
//                         <p className="text-muted-foreground text-center py-4">No checklist template available.</p>
//                       ) : (
//                         <Accordion type="multiple" className="w-full">
//                           {checklistTemplate.map((section) => (
//                             <AccordionItem key={section.id} value={section.id}>
//                               <AccordionTrigger className="text-left">
//                                 <div className="flex items-center gap-3">
//                                   <h3 className="font-medium">{section.name}</h3>
//                                 </div>
//                               </AccordionTrigger>
//                               <AccordionContent>
//                                 <div className="space-y-4">
//                                   <p className="text-sm text-muted-foreground">
//                                     Configure quality control checklist items. Items marked as "Required" will be
//                                     included in the MPI.
//                                   </p>

//                                   <Table>
//                                     <TableHeader>
//                                       <TableRow>
//                                         <TableHead>Description</TableHead>
//                                         <TableHead>Required</TableHead>
//                                         <TableHead>Remarks</TableHead>
//                                       </TableRow>
//                                     </TableHeader>
//                                     <TableBody>
//                                       {(section.items || []).map((item) => (
//                                         <TableRow key={item.id}>
//                                           <TableCell className="font-medium">{item.description}</TableCell>
//                                           <TableCell>
//                                             <Select
//                                               value={
//                                                 getChecklistItemValue(item.id, "required", item.required) ? "yes" : "no"
//                                               }
//                                               onValueChange={(value) =>
//                                                 handleChecklistItemChange(item.id, "required", value === "yes")
//                                               }
//                                             >
//                                               <SelectTrigger className="w-20">
//                                                 <SelectValue />
//                                               </SelectTrigger>
//                                               <SelectContent>
//                                                 <SelectItem value="yes">Yes</SelectItem>
//                                                 <SelectItem value="no">No</SelectItem>
//                                               </SelectContent>
//                                             </Select>
//                                           </TableCell>
//                                           <TableCell>
//                                             <Input
//                                               value={getChecklistItemValue(item.id, "remarks", item.remarks) as string}
//                                               onChange={(e) =>
//                                                 handleChecklistItemChange(item.id, "remarks", e.target.value)
//                                               }
//                                               placeholder="Enter remarks (optional)"
//                                               className="min-w-[200px]"
//                                             />
//                                           </TableCell>
//                                         </TableRow>
//                                       ))}
//                                     </TableBody>
//                                   </Table>
//                                 </div>
//                               </AccordionContent>
//                             </AccordionItem>
//                           ))}
//                         </Accordion>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>

//                 {/* Station Selection Tab */}
//                 <TabsContent value="stations" className="space-y-6 mt-6">
//                   <Card>
//                     <CardContent className="space-y-6 mt-5">
//                       {loadingStations ? (
//                         <div className="flex items-center justify-center py-8">
//                           <div className="text-center">
//                             <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
//                             <p className="mt-2 text-sm text-muted-foreground">Loading stations...</p>
//                           </div>
//                         </div>
//                       ) : availableStations.length === 0 ? (
//                         <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
//                           <p className="text-sm text-yellow-800">No stations available. Create stations first.</p>
//                         </div>
//                       ) : (
//                         <div className="flex gap-6 min-h-[600px]">
//                           {/* Left Sidebar - Station List */}
//                           <div className="w-1/4 border rounded-lg bg-gray-50">
//                             <div className="p-3 border-b bg-white rounded-t-lg">
//                               <h4 className="font-medium text-base">Stations</h4>
//                               <p className="text-xs text-muted-foreground">
//                                 {formData.selectedStationIds.length > 0
//                                   ? `${formData.selectedStationIds.length} selected`
//                                   : "Click to select multiple"}
//                               </p>
//                             </div>
//                             <div className="p-2 overflow-y-auto h-[530px]">
//                               <div className="space-y-1">
//                                 {availableStations.map((station) => (
//                                   <div
//                                     key={station.id}
//                                     className={`p-2 rounded cursor-pointer transition-all text-sm border-2 ${
//                                       formData.selectedStationIds.includes(station.id)
//                                         ? "bg-blue-100 text-blue-900 border-blue-300"
//                                         : "bg-white hover:bg-gray-100 border-transparent"
//                                     } ${activeStationId === station.id ? "ring-2 ring-purple-400 ring-offset-1" : ""}`}
//                                     onClick={() => {
//                                       // Set as active station for viewing specifications
//                                       setActiveStationId(station.id)

//                                       // Handle selection/deselection
//                                       if (formData.selectedStationIds.includes(station.id)) {
//                                         // Remove from selection
//                                         handleStationSelectionChange(
//                                           formData.selectedStationIds.filter((id) => id !== station.id),
//                                         )
//                                       } else {
//                                         // Add to selection
//                                         handleStationSelectionChange([...formData.selectedStationIds, station.id])
//                                       }
//                                     }}
//                                   >
//                                     <div className="flex items-center justify-between">
//                                       <span>{station.stationName}</span>
//                                       {station.documentations && station.documentations.length > 0 && (
//                                         <Badge variant="outline" size="sm" className="text-xs">
//                                           {station.documentations.length} docs
//                                         </Badge>
//                                       )}
//                                     </div>
//                                   </div>
//                                 ))}
//                               </div>
//                             </div>
//                           </div>

//                           {/* Right Panel - Station Specifications and Documents */}
//                           <div className="flex-1 border rounded-lg bg-white">
//                             {activeStationId ? (
//                               <div className="h-full flex flex-col">
//                                 <div className="p-4 border-b bg-white rounded-t-lg">
//                                   <div className="flex items-center justify-between">
//                                     <h4 className="font-medium text-lg">
//                                       {availableStations.find((s) => s.id === activeStationId)?.stationName} Station
//                                     </h4>
//                                     <div className="flex items-center gap-2">
//                                       <Button
//                                         type="button"
//                                         size="sm"
//                                         variant={stationViewMode === "specifications" ? "default" : "outline"}
//                                         onClick={() => setStationViewMode("specifications")}
//                                       >
//                                         Specifications
//                                       </Button>
//                                       <Button
//                                         type="button"
//                                         size="sm"
//                                         variant={stationViewMode === "documents" ? "default" : "outline"}
//                                         onClick={() => setStationViewMode("documents")}
//                                       >
//                                         <FileText className="w-4 h-4 mr-1" />
//                                         Documents
//                                         {(() => {
//                                           const station = availableStations.find((s) => s.id === activeStationId)
//                                           const docCount = station?.documentations?.length || 0
//                                           return docCount > 0 ? (
//                                             <Badge variant="secondary" size="sm" className="ml-1">
//                                               {docCount}
//                                             </Badge>
//                                           ) : null
//                                         })()}
//                                       </Button>
//                                     </div>
//                                   </div>
//                                 </div>
//                                 <div className="flex-1 overflow-y-auto p-4">
//                                   {(() => {
//                                     const activeStation = availableStations.find((s) => s.id === activeStationId)
//                                     if (!activeStation) return null

//                                     if (stationViewMode === "documents") {
//                                       return renderStationDocuments(activeStation)
//                                     }

//                                     return (
//                                       <div>
//                                         {activeStation.specifications && activeStation.specifications.length > 0 ? (
//                                           <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
//                                             {activeStation.specifications.map((spec) => (
//                                               <div key={spec.id} className="space-y-3 p-3 bg-gray-50 rounded border">
//                                                 {renderSpecificationInput(spec, activeStation.id)}
//                                               </div>
//                                             ))}
//                                           </div>
//                                         ) : (
//                                           <div className="text-center py-6 bg-gray-50 rounded border-2 border-dashed">
//                                             <p className="text-muted-foreground">
//                                               No specifications available for this station.
//                                             </p>
//                                           </div>
//                                         )}
//                                       </div>
//                                     )
//                                   })()}
//                                 </div>
//                               </div>
//                             ) : (
//                               <div className="flex items-center justify-center h-full">
//                                 <div className="text-center">
//                                   <Factory className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//                                   <h4 className="font-medium text-gray-600 mb-2">No Station Active</h4>
//                                   <p className="text-sm text-muted-foreground">
//                                     Click on a station from the left sidebar to view its specifications and documents
//                                     {formData.selectedStationIds.length > 0 && (
//                                       <span className="block mt-2 text-blue-600 font-medium">
//                                         {formData.selectedStationIds.length} station
//                                         {formData.selectedStationIds.length > 1 ? "s" : ""} selected for MPI
//                                       </span>
//                                     )}
//                                   </p>
//                                 </div>
//                               </div>
//                             )}
//                           </div>
//                         </div>
//                       )}
//                     </CardContent>
//                   </Card>
//                 </TabsContent>
//               </Tabs>

//               {/* Form Actions */}
//               <div className="flex justify-end gap-4">
//                 <Button variant="outline" onClick={onCancel}>
//                   Cancel
//                 </Button>
//                 <Button type="submit" disabled={isLoading || !isFormValid()}>
//                   {isLoading ? (
//                     <div className="flex items-center gap-2 animate-pulse">
//                       <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-current"></div>
//                       <span>Saving...</span>
//                     </div>
//                   ) : (
//                     <>Create MPI</>
//                   )}
//                 </Button>
//               </div>
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }





















// "use client"

// import { SelectItem } from "@/components/ui/select"

// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File // Store the actual file temporarily
//   fileUrl?: string // Only set after upload
//   description: string
//   fileName: string
//   isUploaded?: boolean // Track upload status
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       // Extract document control IDs from order forms
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Store the file temporarily without uploading
//       const newDoc: MPIDocumentation = {
//         file: file,
//         description: description,
//         fileName: file.name,
//         isUploaded: false,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "Document added successfully. It will be uploaded when the MPI is created.",
//       })
//     } catch (error) {
//       console.error("Document add error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to add document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const uploadDocumentsAfterMPICreation = async (mpiId: string) => {
//     const documentsToUpload = mpiDocumentation.filter((doc) => !doc.isUploaded && doc.file)

//     if (documentsToUpload.length === 0) return

//     try {
//       console.log(`📤 Uploading ${documentsToUpload.length} documents for MPI ${mpiId}`)

//       for (const doc of documentsToUpload) {
//         if (doc.file) {
//           console.log(`📄 Uploading document: ${doc.description}`)
//           await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//         }
//       }

//       toast({
//         title: "Success",
//         description: `${documentsToUpload.length} document(s) uploaded successfully.`,
//       })
//     } catch (error) {
//       console.error("Failed to upload documents:", error)
//       toast({
//         title: "Warning",
//         description: "MPI created successfully, but some documents failed to upload. You can upload them later.",
//         variant: "destructive",
//       })
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null // Optional field
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Refresh existing IDs before validation to ensure we have the latest data
//     await loadExistingIds()

//     // Comprehensive validation - prevent submission if ANY ID is duplicate
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     // Collect all validation errors
//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // CRITICAL: If there are ANY validation errors, show them all and COMPLETELY PREVENT submission
//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000, // Show longer for critical errors
//       })
//       setActiveTab("basic-info")
//       return // COMPLETELY STOP EXECUTION - NO MPI CREATION ATTEMPT
//     }

//     // Additional safety check - double-check all IDs one more time
//     const finalJobIdCheck = existingJobIds.includes(formData.jobId.toLowerCase())
//     const finalAssemblyIdCheck = existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const finalDocControlIdCheck = orderFormData.documentControlId
//       ? existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())
//       : false

//     if (finalJobIdCheck || finalAssemblyIdCheck || finalDocControlIdCheck) {
//       const duplicateIds = []
//       if (finalJobIdCheck) duplicateIds.push(`Job ID: ${formData.jobId}`)
//       if (finalAssemblyIdCheck) duplicateIds.push(`Assembly ID: ${formData.assemblyId}`)
//       if (finalDocControlIdCheck) duplicateIds.push(`Document Control ID: ${orderFormData.documentControlId}`)

//       toast({
//         title: "🚫 CRITICAL: Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold text-red-800">The following IDs already exist in the system:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {duplicateIds.map((id, index) => (
//                 <li key={index} className="text-sm font-medium text-red-700">
//                   {id}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-bold text-red-800">
//               MPI creation has been completely blocked to prevent database errors.
//             </p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 12000,
//       })
//       setActiveTab("basic-info")
//       return // ABSOLUTELY NO SUBMISSION ALLOWED
//     }

//     // Validate enum values before submission
//     const validateEnumValues = () => {
//       if (orderFormData.orderType.length > 0) {
//         const validOrderTypes = enums.orderTypes || []
//         const invalidOrderTypes = orderFormData.orderType.filter((type) => !validOrderTypes.includes(type))
//         if (invalidOrderTypes.length > 0) {
//           toast({
//             title: "Invalid Order Type",
//             description: `Invalid order type(s): ${invalidOrderTypes.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       if (orderFormData.fileAction.length > 0) {
//         const validFileActions = enums.fileActions || []
//         const invalidFileActions = orderFormData.fileAction.filter((action) => !validFileActions.includes(action))
//         if (invalidFileActions.length > 0) {
//           toast({
//             title: "Invalid File Action",
//             description: `Invalid file action(s): ${invalidFileActions.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       return true
//     }

//     // Validate enums
//     if (!validateEnumValues()) {
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     // IMPORTANT: Do NOT include mpiDocumentation in the initial submission
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       // Remove mpiDocumentation from initial submission - we'll upload documents after MPI creation
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           // Ensure orderType values match the Prisma enum exactly
//           orderType: orderFormData.orderType, // Always send as array
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction, // Always send as array
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     // Add instructions if they exist
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")
//     if (validInstructions.length > 0) {
//       submitData.instructions = validInstructions
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       const result = await onSubmit(submitData as CreateMPIDto)

//       // Upload documents after MPI creation if there's an MPI ID returned
//       if (result && result.id && mpiDocumentation.length > 0) {
//         console.log(`🎯 MPI created with ID: ${result.id}, uploading ${mpiDocumentation.length} documents`)
//         await uploadDocumentsAfterMPICreation(result.id)
//       } else if (mpiDocumentation.length > 0) {
//         console.warn("⚠️ MPI created but no ID returned, cannot upload documents")
//       }

//       // If we reach here, the submission was successful
//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle partial success scenarios
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. The MPI creation has been blocked to prevent database errors. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           // Focus on the documentControlId field
//           const docControlInput = document.getElementById("documentControlId")
//           if (docControlInput) {
//             docControlInput.focus()
//           }
//           // Refresh the existing IDs to get the latest data
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         }
//       }

//       // Handle Prisma validation errors
//       if (error.message?.includes("PrismaClientValidationError")) {
//         if (error.message?.includes("orderType")) {
//           toast({
//             title: "Invalid Order Type",
//             description: "The selected order type is not valid. Please check your selection and try again.",
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return
//         }
//       }

//       // Generic error handling with better messaging
//       toast({
//         title: "❌ Submission Error",
//         description: error.message?.includes("MPI")
//           ? "There was an issue creating the MPI. Please check if it was created and try again if needed."
//           : error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   // Set a temporary value to indicate "Other" is selected
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {/* Show input field when "Other" is selected */}
//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     // Additional safety checks
//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               {/* Form Actions */}
//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }













// "use client"

// import { SelectItem } from "@/components/ui/select"

// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"

// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"

// // Import modular components
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<void>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File // Store the actual file temporarily
//   fileUrl?: string // Only set after upload
//   description: string
//   fileName: string
//   isUploaded?: boolean // Track upload status
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State - Updated to handle arrays
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   // Add this after the existing state declarations
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     // Update selected stations when formData.selectedStationIds changes
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       // Extract document control IDs from order forms
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       // Handle the specific backend response structure
//       if (template && Array.isArray(template)) {
//         // Backend returns array of sections with checklistItems
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true, // Change default to Yes (true)
//               remarks: "", // Always leave blank by default
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Store the file temporarily without uploading
//       const newDoc: MPIDocumentation = {
//         file: file,
//         description: description,
//         fileName: file.name,
//         isUploaded: false,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "Document added successfully. It will be uploaded when the MPI is created.",
//       })
//     } catch (error) {
//       console.error("Document add error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to add document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const uploadDocumentsAfterMPICreation = async (mpiId: string) => {
//     const documentsToUpload = mpiDocumentation.filter((doc) => !doc.isUploaded && doc.file)

//     if (documentsToUpload.length === 0) return

//     try {
//       console.log(`📤 Uploading ${documentsToUpload.length} documents for MPI ${mpiId}`)

//       for (const doc of documentsToUpload) {
//         if (doc.file) {
//           console.log(`📄 Uploading document: ${doc.description}`)
//           await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//         }
//       }

//       toast({
//         title: "Success",
//         description: `${documentsToUpload.length} document(s) uploaded successfully.`,
//       })
//     } catch (error) {
//       console.error("Failed to upload documents:", error)
//       toast({
//         title: "Warning",
//         description: "MPI created successfully, but some documents failed to upload. You can upload them later.",
//         variant: "destructive",
//       })
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null // Optional field
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Refresh existing IDs before validation to ensure we have the latest data
//     await loadExistingIds()

//     // Comprehensive validation - prevent submission if ANY ID is duplicate
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     // Collect all validation errors
//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // CRITICAL: If there are ANY validation errors, show them all and COMPLETELY PREVENT submission
//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000, // Show longer for critical errors
//       })
//       setActiveTab("basic-info")
//       return // COMPLETELY STOP EXECUTION - NO MPI CREATION ATTEMPT
//     }

//     // Additional safety check - double-check all IDs one more time
//     const finalJobIdCheck = existingJobIds.includes(formData.jobId.toLowerCase())
//     const finalAssemblyIdCheck = existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const finalDocControlIdCheck = orderFormData.documentControlId
//       ? existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())
//       : false

//     if (finalJobIdCheck || finalAssemblyIdCheck || finalDocControlIdCheck) {
//       const duplicateIds = []
//       if (finalJobIdCheck) duplicateIds.push(`Job ID: ${formData.jobId}`)
//       if (finalAssemblyIdCheck) duplicateIds.push(`Assembly ID: ${formData.assemblyId}`)
//       if (finalDocControlIdCheck) duplicateIds.push(`Document Control ID: ${orderFormData.documentControlId}`)

//       toast({
//         title: "🚫 CRITICAL: Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold text-red-800">The following IDs already exist in the system:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {duplicateIds.map((id, index) => (
//                 <li key={index} className="text-sm font-medium text-red-700">
//                   {id}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-bold text-red-800">
//               MPI creation has been completely blocked to prevent database errors.
//             </p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 12000,
//       })
//       setActiveTab("basic-info")
//       return // ABSOLUTELY NO SUBMISSION ALLOWED
//     }

//     // Validate enum values before submission
//     const validateEnumValues = () => {
//       if (orderFormData.orderType.length > 0) {
//         const validOrderTypes = enums.orderTypes || []
//         const invalidOrderTypes = orderFormData.orderType.filter((type) => !validOrderTypes.includes(type))
//         if (invalidOrderTypes.length > 0) {
//           toast({
//             title: "Invalid Order Type",
//             description: `Invalid order type(s): ${invalidOrderTypes.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       if (orderFormData.fileAction.length > 0) {
//         const validFileActions = enums.fileActions || []
//         const invalidFileActions = orderFormData.fileAction.filter((action) => !validFileActions.includes(action))
//         if (invalidFileActions.length > 0) {
//           toast({
//             title: "Invalid File Action",
//             description: `Invalid file action(s): ${invalidFileActions.join(", ")}. Please select valid options.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return false
//         }
//       }

//       return true
//     }

//     // Validate enums
//     if (!validateEnumValues()) {
//       return
//     }

//     // Prepare checklist data - include all items that have been modified OR have required=true
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               // Include items that are either modified OR have required=true
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   const currentRemarks = modifications?.remarks ?? item.remarks

//                   // Include if required is true OR if it has been modified
//                   return (
//                     currentRequired ||
//                     (modifications &&
//                       (modifications.required !== item.required || modifications.remarks !== item.remarks))
//                   )
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               // Only return section if it has items to include
//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data - only include selected stations with their specifications
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare complete submission data with correct structure
//     // IMPORTANT: Do NOT include mpiDocumentation in the initial submission
//     const submitData = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//       ...(formData.customer && { customer: formData.customer }),
//       // Remove mpiDocumentation from initial submission - we'll upload documents after MPI creation
//       ...(orderFormData.orderType.length > 0 && {
//         orderForms: {
//           // Ensure orderType values match the Prisma enum exactly
//           orderType: orderFormData.orderType, // Always send as array
//           ...(orderFormData.distributionDate && {
//             distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//           }),
//           ...(orderFormData.requiredBy && {
//             requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//           }),
//           ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//           ...(orderFormData.revision && { revision: orderFormData.revision }),
//           ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//           ...(orderFormData.fileAction.length > 0 && {
//             fileAction: orderFormData.fileAction, // Always send as array
//           }),
//           markComplete: orderFormData.markComplete,
//           ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//         },
//       }),
//       ...(stationsData.length > 0 && { stations: stationsData }),
//       ...(checklistsData.length > 0 && { checklists: checklistsData }),
//     }

//     // Add instructions if they exist
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")
//     if (validInstructions.length > 0) {
//       submitData.instructions = validInstructions
//     }

//     console.log("📤 Submitting MPI data:", submitData)

//     try {
//       const result = await onSubmit(submitData as CreateMPIDto)

//       // Upload documents after MPI creation if there's an MPI ID returned
//       if (result && result.id && mpiDocumentation.length > 0) {
//         console.log(`🎯 MPI created with ID: ${result.id}, uploading ${mpiDocumentation.length} documents`)
//         await uploadDocumentsAfterMPICreation(result.id)
//       } else if (mpiDocumentation.length > 0) {
//         console.warn("⚠️ MPI created but no ID returned, cannot upload documents")
//       }

//       // If we reach here, the submission was successful
//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       // Handle partial success scenarios
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. The MPI creation has been blocked to prevent database errors. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           // Focus on the documentControlId field
//           const docControlInput = document.getElementById("documentControlId")
//           if (docControlInput) {
//             docControlInput.focus()
//           }
//           // Refresh the existing IDs to get the latest data
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const jobIdInput = document.getElementById("jobId")
//           if (jobIdInput) {
//             jobIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           const assemblyIdInput = document.getElementById("assemblyId")
//           if (assemblyIdInput) {
//             assemblyIdInput.focus()
//           }
//           await loadExistingIds()
//           return
//         }
//       }

//       // Handle Prisma validation errors
//       if (error.message?.includes("PrismaClientValidationError")) {
//         if (error.message?.includes("orderType")) {
//           toast({
//             title: "Invalid Order Type",
//             description: "The selected order type is not valid. Please check your selection and try again.",
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           return
//         }
//       }

//       // Generic error handling with better messaging
//       toast({
//         title: "❌ Submission Error",
//         description: error.message?.includes("MPI")
//           ? "There was an issue creating the MPI. Please check if it was created and try again if needed."
//           : error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   // Set a temporary value to indicate "Other" is selected
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {/* Show input field when "Other" is selected */}
//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     // Additional safety checks
//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         {/* Header */}
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               {/* Form Actions */}
//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }














// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       const newDoc: MPIDocumentation = {
//         file: file,
//         description: description,
//         fileName: file.name,
//         isUploaded: false,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "Document added successfully. It will be uploaded when the MPI is created.",
//       })
//     } catch (error) {
//       console.error("Document add error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to add document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const uploadDocumentsAfterMPICreation = async (mpiId: string) => {
//     const documentsToUpload = mpiDocumentation.filter((doc) => !doc.isUploaded && doc.file)

//     if (documentsToUpload.length === 0) return

//     try {
//       console.log(`📤 Uploading ${documentsToUpload.length} documents for MPI ${mpiId}`)

//       for (const doc of documentsToUpload) {
//         if (doc.file) {
//           console.log(`📄 Uploading document: ${doc.description}`)
//           await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//         }
//       }

//       toast({
//         title: "Success",
//         description: `${documentsToUpload.length} document(s) uploaded successfully.`,
//       })
//     } catch (error) {
//       console.error("Failed to upload documents:", error)
//       toast({
//         title: "Warning",
//         description: "MPI created successfully, but some documents failed to upload. You can upload them later.",
//         variant: "destructive",
//       })
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("🔄 Starting form submission...")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)

//     // Validation
//     await loadExistingIds()

//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     console.log("📤 Final submission data:", JSON.stringify(submitData, null, 2))

//     try {
//       const result = await onSubmit(submitData)

//       // Upload documents after MPI creation if there's an MPI ID returned
//       if (result && result.id && mpiDocumentation.length > 0) {
//         console.log(`🎯 MPI created with ID: ${result.id}, uploading ${mpiDocumentation.length} documents`)
//         await uploadDocumentsAfterMPICreation(result.id)
//       } else if (mpiDocumentation.length > 0) {
//         console.warn("⚠️ MPI created but no ID returned, cannot upload documents")
//       }

//       toast({
//         title: "✅ Success",
//         description: "MPI created successfully!",
//         variant: "default",
//       })
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ Submission Error",
//         description: error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }






















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       const newDoc: MPIDocumentation = {
//         file: file,
//         description: description,
//         fileName: file.name,
//         isUploaded: false,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "Document added successfully. It will be uploaded when the MPI is created.",
//       })
//     } catch (error) {
//       console.error("Document add error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to add document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const uploadDocumentsAfterMPICreation = async (mpiId: string) => {
//     const documentsToUpload = mpiDocumentation.filter((doc) => !doc.isUploaded && doc.file)

//     if (documentsToUpload.length === 0) {
//       console.log("📝 No documents to upload")
//       return
//     }

//     try {
//       console.log(`📤 Uploading ${documentsToUpload.length} documents for MPI ${mpiId}`)

//       const uploadPromises = documentsToUpload.map(async (doc, index) => {
//         if (doc.file) {
//           console.log(`📄 Uploading document ${index + 1}/${documentsToUpload.length}: ${doc.description}`)
//           try {
//             const result = await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//             console.log(`✅ Document uploaded successfully:`, result)
//             return result
//           } catch (error) {
//             console.error(`❌ Failed to upload document: ${doc.description}`, error)
//             throw error
//           }
//         }
//       })

//       const results = await Promise.all(uploadPromises)
//       console.log(`✅ All ${results.length} documents uploaded successfully`)

//       toast({
//         title: "✅ Success",
//         description: `MPI created successfully with ${results.length} document(s) uploaded.`,
//       })
//     } catch (error) {
//       console.error("❌ Failed to upload documents:", error)
//       toast({
//         title: "⚠️ Partial Success",
//         description:
//           "MPI created successfully, but some documents failed to upload. You can upload them later from the MPI details page.",
//         variant: "destructive",
//       })
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("🔄 Starting form submission...")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)

//     // Validation
//     await loadExistingIds()

//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     console.log("📤 Final submission data:", JSON.stringify(submitData, null, 2))

//     try {
//       const result = await onSubmit(submitData)
//       console.log("✅ MPI created successfully:", result)

//       // Upload documents after MPI creation if there's an MPI ID returned
//       if (result && result.id && mpiDocumentation.length > 0) {
//         console.log(`🎯 MPI created with ID: ${result.id}, uploading ${mpiDocumentation.length} documents`)
//         await uploadDocumentsAfterMPICreation(result.id)
//       } else if (mpiDocumentation.length > 0) {
//         console.warn("⚠️ MPI created but no ID returned, cannot upload documents")
//         toast({
//           title: "⚠️ Warning",
//           description:
//             "MPI created successfully, but documents could not be uploaded. Please upload them manually from the MPI details page.",
//           variant: "destructive",
//         })
//       } else {
//         // No documents to upload, show success message
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ Submission Error",
//         description: error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }

















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       const newDoc: MPIDocumentation = {
//         file: file,
//         description: description,
//         fileName: file.name,
//         isUploaded: false,
//       }

//       setMpiDocumentation((prev) => [...prev, newDoc])

//       toast({
//         title: "Success",
//         description: "Document added successfully. It will be uploaded when the MPI is created.",
//       })
//     } catch (error) {
//       console.error("Document add error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to add document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const uploadDocumentsAfterMPICreation = async (mpiId: string) => {
//     const documentsToUpload = mpiDocumentation.filter((doc) => !doc.isUploaded && doc.file)

//     if (documentsToUpload.length === 0) {
//       console.log("📝 No documents to upload")
//       return { success: true, uploadedCount: 0 }
//     }

//     try {
//       console.log(`📤 Starting upload of ${documentsToUpload.length} documents for MPI ${mpiId}`)

//       const uploadResults = []
//       let successCount = 0
//       let failureCount = 0

//       // Upload documents one by one with detailed logging
//       for (let i = 0; i < documentsToUpload.length; i++) {
//         const doc = documentsToUpload[i]
//         if (doc.file) {
//           try {
//             console.log(`📄 Uploading document ${i + 1}/${documentsToUpload.length}:`)
//             console.log(`   - File: ${doc.file.name}`)
//             console.log(`   - Size: ${doc.file.size} bytes`)
//             console.log(`   - Description: ${doc.description}`)
//             console.log(`   - MPI ID: ${mpiId}`)

//             const result = await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)

//             console.log(`✅ Document ${i + 1} uploaded successfully:`, result)
//             uploadResults.push({ success: true, document: doc, result })
//             successCount++

//             // Update the document state to mark as uploaded
//             setMpiDocumentation((prev) =>
//               prev.map((prevDoc) =>
//                 prevDoc === doc ? { ...prevDoc, isUploaded: true, id: result.id, fileUrl: result.fileUrl } : prevDoc,
//               ),
//             )
//           } catch (error) {
//             console.error(`❌ Failed to upload document ${i + 1}: ${doc.description}`, error)
//             uploadResults.push({ success: false, document: doc, error })
//             failureCount++
//           }
//         }
//       }

//       console.log(`📊 Upload Summary:`)
//       console.log(`   - Total documents: ${documentsToUpload.length}`)
//       console.log(`   - Successful uploads: ${successCount}`)
//       console.log(`   - Failed uploads: ${failureCount}`)

//       if (successCount === documentsToUpload.length) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with all ${successCount} document(s) uploaded.`,
//         })
//         return { success: true, uploadedCount: successCount }
//       } else if (successCount > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: `MPI created successfully. ${successCount} of ${documentsToUpload.length} documents uploaded. ${failureCount} failed.`,
//           variant: "destructive",
//         })
//         return { success: false, uploadedCount: successCount, failedCount: failureCount }
//       } else {
//         toast({
//           title: "❌ Upload Failed",
//           description: `MPI created successfully, but all ${documentsToUpload.length} document uploads failed. You can upload them later.`,
//           variant: "destructive",
//         })
//         return { success: false, uploadedCount: 0, failedCount: failureCount }
//       }
//     } catch (error) {
//       console.error("💥 Critical error during document upload:", error)
//       toast({
//         title: "❌ Upload Error",
//         description:
//           "MPI created successfully, but document upload encountered a critical error. Please upload documents manually.",
//         variant: "destructive",
//       })
//       return { success: false, uploadedCount: 0, error }
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("🔄 Starting form submission...")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)
//     console.log("📄 Documents to upload:", mpiDocumentation.length)

//     // Validation
//     await loadExistingIds()

//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     console.log("📤 Final submission data:", JSON.stringify(submitData, null, 2))

//     try {
//       console.log("🚀 Calling onSubmit with MPI data...")
//       const result = await onSubmit(submitData)
//       console.log("✅ MPI created successfully:", result)

//       // Check if we have documents to upload and a valid MPI ID
//       if (mpiDocumentation.length > 0) {
//         console.log(`📋 Found ${mpiDocumentation.length} documents to upload`)

//         // Extract MPI ID from result
//         let mpiId = null
//         if (result && typeof result === "object") {
//           mpiId = result.id || result.mpiId || result.data?.id
//         }

//         console.log(`🎯 Extracted MPI ID: ${mpiId}`)

//         if (mpiId) {
//           console.log(`📤 Starting document upload process for MPI: ${mpiId}`)
//           const uploadResult = await uploadDocumentsAfterMPICreation(mpiId)
//           console.log("📊 Document upload result:", uploadResult)
//         } else {
//           console.error("⚠️ No MPI ID found in result, cannot upload documents")
//           console.log("🔍 Full result object:", JSON.stringify(result, null, 2))
//           toast({
//             title: "⚠️ Warning",
//             description:
//               "MPI created successfully, but documents could not be uploaded due to missing MPI ID. Please upload them manually.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         console.log("📝 No documents to upload")
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("Form submission error:", error)

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ Submission Error",
//         description: error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }





















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       console.error("Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("📦 Enums loaded:", enumsData)
//     } catch (error) {
//       console.error("Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       console.error("Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     console.log("🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE")
//     console.log("📄 File:", file.name, file.size, "bytes")
//     console.log("📝 Description:", description)

//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       const finalDescription = description.trim() || file.name

//       console.log("💾 QUEUING document locally - NO UPLOAD YET...")

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         console.log("📋 Updated document queue:", updated.length, "documents")
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       console.log("✅ Document queued successfully - waiting for MPI creation")
//     } catch (error) {
//       console.error("❌ Document queue error:", error)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       console.log("🗑️ Document removed, updated list:", updated)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("\n🚀 === STARTING FORM SUBMISSION ===")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)
//     console.log("📄 Documents in queue:", mpiDocumentation.length)

//     // Validation
//     await loadExistingIds()

//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Cannot Create MPI - Duplicate IDs Detected",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">MPI creation blocked due to duplicate IDs:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//             <p className="text-xs mt-2 font-medium">Please fix all duplicate IDs before proceeding.</p>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     // Add uploaded documents to submission data
//     if (mpiDocumentation.length > 0) {
//       const uploadedDocs = mpiDocumentation
//         .filter((doc) => doc.isUploaded && doc.fileUrl)
//         .map((doc) => ({
//           fileUrl: doc.fileUrl,
//           description: doc.description,
//         }))

//       if (uploadedDocs.length > 0) {
//         submitData.mpiDocs = uploadedDocs
//       }
//     }

//     console.log("📤 Final submission data:", JSON.stringify(submitData, null, 2))

//     try {
//       console.log("🚀 STEP 1: Creating MPI first...")
//       const result = await onSubmit(submitData)
//       console.log("✅ STEP 1 COMPLETE: MPI created successfully:", result)

//       // Enhanced MPI ID extraction with better error handling
//       let mpiId = null

//       if (result) {
//         // Try multiple possible locations for the MPI ID
//         mpiId = result.id || result.mpiId || result.data?.id || result.data?.mpiId

//         console.log("🔍 === MPI ID EXTRACTION DEBUG ===")
//         console.log("🔍 Result type:", typeof result)
//         console.log("🔍 Result keys:", Object.keys(result || {}))
//         console.log("🔍 result.id:", result.id)
//         console.log("🔍 result.mpiId:", result.mpiId)
//         console.log("🔍 result.data?.id:", result.data?.id)
//         console.log("🔍 result.data?.mpiId:", result.data?.mpiId)
//         console.log("🔍 Extracted MPI ID:", mpiId)
//         console.log("🔍 Full result object:", JSON.stringify(result, null, 2))
//       } else {
//         console.error("❌ Result is null or undefined")
//       }

//       // STEP 2: Upload documents ONLY AFTER MPI creation succeeds
//       if (mpiDocumentation.length > 0) {
//         if (mpiId) {
//           console.log(`🚀 STEP 2: Uploading ${mpiDocumentation.length} documents AFTER MPI creation...`)

//           let uploadedCount = 0
//           let failedCount = 0

//           for (const [index, doc] of mpiDocumentation.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 console.log(`📤 Uploading document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//                 await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//                 console.log(`✅ Document ${index + 1} uploaded successfully: ${doc.description}`)
//                 uploadedCount++
//               } catch (uploadError) {
//                 console.error(`❌ Failed to upload document ${index + 1} (${doc.description}):`, uploadError)
//                 failedCount++
//                 // Continue with other documents even if one fails
//               }
//             }
//           }

//           console.log(`📊 Upload summary: ${uploadedCount} successful, ${failedCount} failed`)

//           if (failedCount > 0) {
//             toast({
//               title: "⚠️ Partial Success",
//               description: `MPI created successfully. ${uploadedCount} documents uploaded, ${failedCount} failed.`,
//               variant: "destructive",
//             })
//           } else {
//             toast({
//               title: "✅ Complete Success",
//               description: `MPI created successfully with ${uploadedCount} document(s) uploaded!`,
//               variant: "default",
//             })
//           }
//         } else {
//           console.warn("⚠️ Could not extract MPI ID from result - documents will not be uploaded")
//           console.warn("⚠️ Result structure:", JSON.stringify(result, null, 2))
//           toast({
//             title: "⚠️ Warning",
//             description:
//               "MPI created but documents could not be uploaded due to missing MPI ID. Please upload them manually.",
//             variant: "destructive",
//           })
//         }
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("❌ STEP 1 FAILED: MPI creation error:", error)
//       console.error("❌ Error details:", {
//         message: error.message,
//         stack: error.stack,
//         name: error.name,
//       })

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ Submission Error",
//         description: error.message || "Failed to save MPI. Please try again.",
//         variant: "destructive",
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         unit,
//         fileUrl: prev[specificationId]?.fileUrl,
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     setUploadingFiles((prev) => new Set(prev).add(specificationId))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || file.name,
//           fileUrl: result.fileUrl,
//           unit,
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("File upload error:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(specificationId)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const isUploading = uploadingFiles.has(spec.id)

//     switch (spec.inputType) {
//       case "TEXT":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="flex gap-2">
//               <Input
//                 id={`spec-${spec.id}`}
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div className="space-y-2">
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 id={`spec-${spec.id}`}
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label htmlFor={`spec-${spec.id}`} className="text-sm font-medium">
//                 {spec.name}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         const hasOtherOption = !suggestions.includes("Other")
//         const allOptions = hasOtherOption ? [...suggestions, "Other"] : suggestions
//         const isOtherSelected =
//           specValue?.value === "Other" || (specValue?.value && !suggestions.includes(specValue.value))

//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Select
//               value={isOtherSelected ? "Other" : specValue?.value || ""}
//               onValueChange={(value) => {
//                 if (value === "Other") {
//                   handleSpecificationValueChange(spec.id, "Other")
//                 } else {
//                   handleSpecificationValueChange(spec.id, value)
//                 }
//               }}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {allOptions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>

//             {isOtherSelected && (
//               <div className="space-y-2">
//                 <Label htmlFor={`spec-${spec.id}-other`} className="text-sm text-muted-foreground">
//                   Enter custom value:
//                 </Label>
//                 <Input
//                   id={`spec-${spec.id}-other`}
//                   value={specValue?.value === "Other" ? "" : specValue?.value || ""}
//                   onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//                   placeholder={`Enter custom ${spec.name.toLowerCase()}`}
//                   className="h-10"
//                   autoFocus
//                 />
//               </div>
//             )}
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   id={`spec-${spec.id}`}
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept="*/*"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-5 h-5 text-green-600 mt-1 flex-shrink-0" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                   <a
//                     href={specValue.fileUrl}
//                     target="_blank"
//                     rel="noopener noreferrer"
//                     className="text-xs text-blue-600 hover:underline"
//                   >
//                     View
//                   </a>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">All file types supported. No size limit.</p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div className="space-y-2">
//             <Label htmlFor={`spec-${spec.id}`}>{spec.name}</Label>
//             <Input
//               id={`spec-${spec.id}`}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const documents = station.documentations || []

//     if (documents.length === 0) {
//       return (
//         <div className="text-center py-8 bg-gray-50 rounded border-2 border-dashed">
//           <FileText className="w-12 h-12 text-gray-400 mx-auto mb-4" />
//           <p className="text-muted-foreground">No documents available for this station.</p>
//         </div>
//       )
//     }

//     return (
//       <div className="space-y-4">
//         <div className="grid grid-cols-1 gap-4">
//           {documents.map((doc, index) => (
//             <div key={doc.id || index} className="p-4 bg-white border rounded-lg shadow-sm">
//               <div className="flex items-start justify-between">
//                 <div className="flex items-start gap-3 flex-1">
//                   <FileText className="w-5 h-5 text-blue-600 mt-1 flex-shrink-0" />
//                   <div className="flex-1 min-w-0">
//                     <h4 className="font-medium text-sm text-gray-900 truncate">
//                       {doc.description || "Untitled Document"}
//                     </h4>
//                     <p className="text-xs text-gray-500 mt-1">
//                       Uploaded: {doc.createdAt ? new Date(doc.createdAt).toLocaleDateString() : "Unknown date"}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2 ml-4">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-8 px-3"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description || "document"
//                       link.click()
//                     }}
//                     className="h-8 px-3"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             </div>
//           ))}
//         </div>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const hasJobId = formData.jobId.trim()
//     const hasAssemblyId = formData.assemblyId.trim()
//     const jobIdValid = !validateJobId(formData.jobId)
//     const assemblyIdValid = !validateAssemblyId(formData.assemblyId)
//     const documentControlIdValid =
//       !orderFormData.documentControlId || !validateDocumentControlId(orderFormData.documentControlId)

//     const noJobIdDuplicate = !existingJobIds.includes(formData.jobId.toLowerCase())
//     const noAssemblyIdDuplicate = !existingAssemblyIds.includes(formData.assemblyId.toLowerCase())
//     const noDocControlIdDuplicate =
//       !orderFormData.documentControlId ||
//       !existingDocumentControlIds.includes(orderFormData.documentControlId.toLowerCase())

//     return (
//       hasJobId &&
//       hasAssemblyId &&
//       jobIdValid &&
//       assemblyIdValid &&
//       documentControlIdValid &&
//       noJobIdDuplicate &&
//       noAssemblyIdDuplicate &&
//       noDocControlIdDuplicate &&
//       !checkingIds
//     )
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <div className=" space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <form onSubmit={handleSubmit} className="space-y-6">
//               <MPIFormTabs
//                 activeTab={activeTab}
//                 onTabChange={setActiveTab}
//                 documentationCount={mpiDocumentation.length}
//                 checklistCount={checklistTemplate.length}
//                 selectedStationsCount={selectedStations.length}
//                 formData={formData}
//                 orderFormData={orderFormData}
//                 enums={enums}
//                 loadingEnums={loadingEnums}
//                 checkingIds={checkingIds}
//                 onFormDataChange={handleChange}
//                 onOrderFormChange={handleOrderFormChange}
//                 validateJobId={validateJobId}
//                 validateAssemblyId={validateAssemblyId}
//                 validateDocumentControlId={validateDocumentControlId}
//                 mpiDocumentation={mpiDocumentation}
//                 uploadingMpiDoc={uploadingMpiDoc}
//                 onDocumentUpload={handleMpiDocumentUpload}
//                 onRemoveDocument={removeMpiDocument}
//                 toast={toast}
//                 checklistTemplate={checklistTemplate}
//                 loadingChecklist={loadingChecklist}
//                 checklistModifications={checklistModifications}
//                 onChecklistItemChange={handleChecklistItemChange}
//                 getChecklistItemValue={getChecklistItemValue}
//                 availableStations={availableStations}
//                 selectedStationIds={formData.selectedStationIds}
//                 loadingStations={loadingStations}
//                 activeStationId={activeStationId}
//                 stationViewMode={stationViewMode}
//                 specificationValues={specificationValues}
//                 uploadingFiles={uploadingFiles}
//                 onStationSelectionChange={handleStationSelectionChange}
//                 onActiveStationChange={setActiveStationId}
//                 onStationViewModeChange={setStationViewMode}
//                 onSpecificationValueChange={handleSpecificationValueChange}
//                 onFileUpload={handleFileUpload}
//                 renderSpecificationInput={renderSpecificationInput}
//                 renderStationDocuments={renderStationDocuments}
//                 instructions={instructions}
//                 onAddInstruction={handleAddInstruction}
//                 onInstructionChange={handleInstructionChange}
//                 onRemoveInstruction={handleRemoveInstruction}
//               />

//               <MPIFormActions isLoading={isLoading || false} isFormValid={isFormValid()} onCancel={onCancel} />
//             </form>
//           </CardContent>
//         </Card>
//       </div>
//     </div>
//   )
// }









// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { StationMpiDocAPI } from "./station-mpi-doc-api"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       console.log("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       console.log("✅ Stations loaded:", stations.length)
//     } catch (error) {
//       console.error("❌ Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       console.log("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("✅ Enums loaded:", {
//         orderTypes: enumsData.orderTypes?.length || 0,
//         fileActions: enumsData.fileActions?.length || 0,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       console.log("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()

//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       console.log("✅ Existing IDs loaded:", {
//         jobIds: jobIds.length,
//         assemblyIds: assemblyIds.length,
//         documentControlIds: documentControlIds.length,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       console.log("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("⚠️ Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("❌ Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     console.log("📤 Station document upload (QUEUE MODE):", {
//       stationId,
//       fileName: file.name,
//       description,
//     })

//     try {
//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       console.log("✅ Station document queued successfully")
//     } catch (error) {
//       console.error("❌ Failed to queue station document:", error)
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))

//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the queue.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     console.log("🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE")
//     console.log("📄 File:", file.name, file.size, "bytes")
//     console.log("📝 Description:", description)

//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       const finalDescription = description.trim() || file.name

//       console.log("💾 QUEUING document locally - NO UPLOAD YET...")

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         console.log("📋 Updated document queue:", updated.length, "documents")
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       console.log("✅ Document queued successfully - waiting for MPI creation")
//     } catch (error) {
//       console.error("❌ Document queue error:", error)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       console.log("🗑️ Document removed, updated list:", updated)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("\n🚀 === STARTING FORM SUBMISSION ===")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)
//     console.log("📄 MPI Documents in queue:", mpiDocumentation.length)
//     console.log(
//       "📁 Station Documents in queue:",
//       Object.keys(stationDocuments).reduce((total, stationId) => total + stationDocuments[stationId].length, 0),
//     )

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       console.error("❌ Validation failed:", validationErrors)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     // Add uploaded documents to submission data
//     if (mpiDocumentation.length > 0) {
//       const uploadedDocs = mpiDocumentation
//         .filter((doc) => doc.isUploaded && doc.fileUrl)
//         .map((doc) => ({
//           fileUrl: doc.fileUrl,
//           description: doc.description,
//         }))

//       if (uploadedDocs.length > 0) {
//         submitData.mpiDocs = uploadedDocs
//       }
//     }

//     console.log("📤 Final submission data:", {
//       jobId: submitData.jobId,
//       assemblyId: submitData.assemblyId,
//       customer: submitData.customer,
//       instructionsCount: submitData.Instruction?.length || 0,
//       stationsCount: submitData.stations?.length || 0,
//       checklistsCount: submitData.checklists?.length || 0,
//       mpiDocsCount: submitData.mpiDocs?.length || 0,
//       orderFormsIncluded: !!submitData.orderForms,
//     })

//     try {
//       console.log("🚀 STEP 1: Creating MPI first...")
//       const result = await onSubmit(submitData)
//       console.log("✅ STEP 1 COMPLETE: MPI created successfully:", result)

//       // Enhanced MPI ID extraction with better error handling
//       let mpiId = null

//       if (result) {
//         // Try multiple possible locations for the MPI ID
//         mpiId = result.id || result.mpiId || result.data?.id || result.data?.mpiId

//         console.log("🔍 === MPI ID EXTRACTION DEBUG ===")
//         console.log("🔍 Result type:", typeof result)
//         console.log("🔍 Result keys:", Object.keys(result || {}))
//         console.log("🔍 Extracted MPI ID:", mpiId)

//         if (!mpiId) {
//           console.error("❌ Could not extract MPI ID from result")
//           console.error("❌ Full result object:", JSON.stringify(result, null, 2))
//         }
//       } else {
//         console.error("❌ Result is null or undefined")
//       }

//       // STEP 2: Upload MPI documents ONLY AFTER MPI creation succeeds
//       const mpiDocUploadResults = { uploaded: 0, failed: 0 }
//       if (mpiDocumentation.length > 0 && mpiId) {
//         console.log(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               console.log(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               console.log(`✅ MPI Document ${index + 1} uploaded successfully: ${doc.description}`)
//               mpiDocUploadResults.uploaded++
//             } catch (uploadError) {
//               console.error(`❌ Failed to upload MPI document ${index + 1} (${doc.description}):`, uploadError)
//               mpiDocUploadResults.failed++
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents ONLY AFTER MPI creation succeeds
//       const stationDocUploadResults = { uploaded: 0, failed: 0 }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0 && mpiId) {
//         console.log(`🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 console.log(`📤 Uploading station document for station ${stationId}: ${doc.description}`)
//                 const result = await StationMpiDocAPI.create(
//                   {
//                     stationId: doc.stationId,
//                     description: doc.description,
//                     mpiId: mpiId,
//                   },
//                   doc.file,
//                 )
//                 console.log(`✅ Station document uploaded successfully:`, result)
//                 stationDocUploadResults.uploaded++
//               } catch (uploadError) {
//                 console.error(`❌ Failed to upload station document (${doc.description}):`, uploadError)
//                 stationDocUploadResults.failed++
//               }
//             }
//           }
//         }
//       }

//       // Final success message
//       const totalUploaded = mpiDocUploadResults.uploaded + stationDocUploadResults.uploaded
//       const totalFailed = mpiDocUploadResults.failed + stationDocUploadResults.failed

//       console.log(`📊 Final upload summary:`)
//       console.log(`📊 MPI Documents: ${mpiDocUploadResults.uploaded} uploaded, ${mpiDocUploadResults.failed} failed`)
//       console.log(
//         `📊 Station Documents: ${stationDocUploadResults.uploaded} uploaded, ${stationDocUploadResults.failed} failed`,
//       )
//       console.log(`📊 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: `MPI created successfully. ${totalUploaded} documents uploaded, ${totalFailed} failed.`,
//           variant: "destructive",
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("❌ STEP 1 FAILED: MPI creation error:", error)
//       console.error("❌ Error details:", {
//         message: error.message,
//         stack: error.stack,
//         name: error.name,
//       })

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobI}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       console.log("📤 Uploading specification file:", {
//         specificationId,
//         stationId,
//         fileName: file.name,
//         unit,
//       })

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       console.log("✅ File uploaded successfully:", result)

//       // Update the specification value with the file URL
//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("❌ File upload failed:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>
//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />
//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}
//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     return (
//       <div className="space-y-4">
//         <p className="text-sm text-gray-600">Station documents will be managed in the Instructions tab.</p>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               // Station document props
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }









// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})

//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})

//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])

//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       console.log("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       console.log("✅ Stations loaded:", stations.length)
//     } catch (error) {
//       console.error("❌ Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       console.log("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("✅ Enums loaded:", {
//         orderTypes: enumsData.orderTypes?.length || 0,
//         fileActions: enumsData.fileActions?.length || 0,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       console.log("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()

//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())

//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       console.log("✅ Existing IDs loaded:", {
//         jobIds: jobIds.length,
//         assemblyIds: assemblyIds.length,
//         documentControlIds: documentControlIds.length,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       console.log("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("⚠️ Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("❌ Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     console.log("📤 Station document upload (QUEUE MODE):", {
//       stationId,
//       fileName: file.name,
//       description,
//     })

//     try {
//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       console.log("✅ Station document queued successfully")
//     } catch (error) {
//       console.error("❌ Failed to queue station document:", error)
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))

//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     console.log("🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE")
//     console.log("📄 File:", file.name, file.size, "bytes")
//     console.log("📝 Description:", description)

//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       const finalDescription = description.trim() || file.name

//       console.log("💾 QUEUING document locally - NO UPLOAD YET...")

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         console.log("📋 Updated document queue:", updated.length, "documents")
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       console.log("✅ Document queued successfully - waiting for MPI creation")
//     } catch (error) {
//       console.error("❌ Document queue error:", error)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       console.log("🗑️ Document removed, updated list:", updated)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("\n🚀 === STARTING FORM SUBMISSION ===")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)
//     console.log("📄 MPI Documents in queue:", mpiDocumentation.length)
//     console.log(
//       "📁 Station Documents in queue:",
//       Object.keys(stationDocuments).reduce((total, stationId) => total + stationDocuments[stationId].length, 0),
//     )

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       console.error("❌ Validation failed:", validationErrors)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     // Add uploaded documents to submission data
//     if (mpiDocumentation.length > 0) {
//       const uploadedDocs = mpiDocumentation
//         .filter((doc) => doc.isUploaded && doc.fileUrl)
//         .map((doc) => ({
//           fileUrl: doc.fileUrl,
//           description: doc.description,
//         }))

//       if (uploadedDocs.length > 0) {
//         submitData.mpiDocs = uploadedDocs
//       }
//     }

//     // DO NOT include stationMpiDocuments in the initial MPI creation
//     // We'll handle station document uploads separately after MPI creation

//     console.log("📤 Final submission data (WITHOUT station documents):", {
//       jobId: submitData.jobId,
//       assemblyId: submitData.assemblyId,
//       customer: submitData.customer,
//       instructionsCount: submitData.Instruction?.length || 0,
//       stationsCount: submitData.stations?.length || 0,
//       checklistsCount: submitData.checklists?.length || 0,
//       mpiDocsCount: submitData.mpiDocs?.length || 0,
//       orderFormsIncluded: !!submitData.orderForms,
//       stationDocumentsToUploadAfter: Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       ),
//     })

//     // Add debugging before submission
//     console.log("\n🚀 === MPI CREATION DEBUG START ===")
//     console.log("📝 Basic Info:", {
//       jobId: submitData.jobId,
//       assemblyId: submitData.assemblyId,
//       customer: submitData.customer,
//     })
//     console.log("📋 Instructions:", submitData.Instruction?.length || 0)
//     console.log("🏭 Stations:", submitData.stations?.length || 0)
//     console.log("📄 MPI Documents:", submitData.mpiDocs?.length || 0)

//     const totalDocs = Object.keys(stationDocuments).reduce(
//       (total, stationId) => total + stationDocuments[stationId].length,
//       0,
//     )
//     console.log("\n📁 === STATION DOCUMENT QUEUE ===")
//     console.log("📊 Total queued documents:", totalDocs)
//     Object.entries(stationDocuments).forEach(([stationId, docs]) => {
//       console.log(`🏭 Station ${stationId}:`, docs.length, "documents")
//       docs.forEach((doc, index) => {
//         console.log(`  📄 ${index + 1}. ${doc.description} (${doc.fileName})`)
//       })
//     })

//     try {
//       console.log("🚀 STEP 1: Creating MPI first (WITHOUT station documents)...")
//       const result = await onSubmit(submitData)
//       console.log("✅ STEP 1 COMPLETE: MPI created successfully:", result)

//       // Enhanced MPI ID extraction with debugging
//       console.log("\n✅ === MPI CREATION RESULT ===")
//       console.log("🆔 MPI ID extraction attempts:")
//       console.log("  - result.id:", result?.id)
//       console.log("  - result.mpiId:", result?.mpiId)
//       console.log("  - result.data?.id:", result?.data?.id)
//       console.log("  - result.data?.mpiId:", result?.data?.mpiId)

//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId
//       console.log("🎯 Final extracted MPI ID:", mpiId)

//       if (!mpiId) {
//         console.error("❌ CRITICAL: No MPI ID could be extracted!")
//         console.error("❌ Full result object:", JSON.stringify(result, null, 2))
//       }

//       // STEP 2: Upload MPI documents ONLY AFTER MPI creation succeeds
//       const mpiDocUploadResults = { uploaded: 0, failed: 0 }
//       if (mpiDocumentation.length > 0 && mpiId) {
//         console.log(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               console.log(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               console.log(`✅ MPI Document ${index + 1} uploaded successfully: ${doc.description}`)
//               mpiDocUploadResults.uploaded++
//             } catch (uploadError) {
//               console.error(`❌ Failed to upload MPI document ${index + 1} (${doc.description}):`, uploadError)
//               mpiDocUploadResults.failed++
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents ONLY AFTER MPI creation succeeds
//       const stationDocUploadResults = { uploaded: 0, failed: 0 }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0 && mpiId) {
//         console.log(`🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           console.log(`📁 Processing ${docs.length} documents for station ${stationId}`)

//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               console.log(`\n📤 === UPLOADING STATION DOCUMENT ${index + 1}/${docs.length} ===`)
//               console.log("🏭 Station ID:", stationId)
//               console.log("🆔 MPI ID:", mpiId)
//               console.log("📄 Document:", {
//                 description: doc.description,
//                 fileName: doc.fileName,
//                 fileSize: doc.file?.size,
//               })

//               try {
//                 // Create FormData for the upload
//                 const formData = new FormData()
//                 formData.append("files", doc.file)
//                 formData.append("stationId", stationId)
//                 formData.append("description", doc.description)
//                 formData.append("mpiId", mpiId)
//                 formData.append("originalName", doc.fileName)

//                 console.log("📤 Sending station document upload request...")

//                 const response = await fetch(
//                   `${API_BASE_URL}/station-mpi-documents/upload`,
//                   {
//                     method: "POST",
//                     body: formData,
//                   },
//                 )

//                 console.log("📥 Upload response status:", response.status)

//                 if (!response.ok) {
//                   const errorText = await response.text()
//                   console.error("❌ Upload failed:", errorText)
//                   throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`)
//                 }

//                 const uploadResult = await response.json()
//                 console.log("✅ Station document uploaded successfully:", uploadResult)

//                 // Verify the document was properly linked
//                 const document = Array.isArray(uploadResult) ? uploadResult[0] : uploadResult
//                 if (document.mpiId !== mpiId) {
//                   console.warn("⚠️ Document MPI ID mismatch:", {
//                     expected: mpiId,
//                     actual: document.mpiId,
//                   })
//                 } else {
//                   console.log("✅ Document properly linked to MPI:", document.mpiId)
//                 }

//                 stationDocUploadResults.uploaded++
//               } catch (uploadError) {
//                 console.error(`❌ Failed to upload station document ${index + 1}:`, uploadError)
//                 console.error("❌ Error details:", {
//                   message: uploadError.message,
//                   stationId,
//                   fileName: doc.fileName,
//                   description: doc.description,
//                 })
//                 stationDocUploadResults.failed++
//               }
//             }
//           }
//         }

//         console.log(
//           `📊 Station document upload complete: ${stationDocUploadResults.uploaded} uploaded, ${stationDocUploadResults.failed} failed`,
//         )
//       } else if (totalStationDocs > 0 && !mpiId) {
//         console.error(`❌ Cannot upload ${totalStationDocs} station documents - MPI ID not available`)
//         console.error("❌ MPI creation result:", result)
//       }

//       // Final summary with debugging
//       console.log("\n📊 === FINAL UPLOAD SUMMARY ===")
//       console.log("📄 MPI Documents:", {
//         uploaded: mpiDocUploadResults.uploaded,
//         failed: mpiDocUploadResults.failed,
//       })
//       console.log("📁 Station Documents:", {
//         uploaded: stationDocUploadResults.uploaded,
//         failed: stationDocUploadResults.failed,
//       })
//       console.log("🎯 Total Success:", mpiDocUploadResults.uploaded + stationDocUploadResults.uploaded)
//       console.log("❌ Total Failed:", mpiDocUploadResults.failed + stationDocUploadResults.failed)

//       // Final success message
//       const totalUploaded = mpiDocUploadResults.uploaded + stationDocUploadResults.uploaded
//       const totalFailed = mpiDocUploadResults.failed + stationDocUploadResults.failed

//       console.log(`📊 Final upload summary:`)
//       console.log(`📊 MPI Documents: ${mpiDocUploadResults.uploaded} uploaded, ${mpiDocUploadResults.failed} failed`)
//       console.log(
//         `📊 Station Documents: ${stationDocUploadResults.uploaded} uploaded, ${stationDocUploadResults.failed} failed`,
//       )
//       console.log(`📊 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: `MPI created successfully. ${totalUploaded} documents uploaded, ${totalFailed} failed.`,
//           variant: "destructive",
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("❌ STEP 1 FAILED: MPI creation error:", error)
//       console.error("❌ Error details:", {
//         message: error.message,
//         stack: error.stack,
//         name: error.name,
//       })

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobI}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       console.log("📤 Uploading specification file:", {
//         specificationId,
//         stationId,
//         fileName: file.name,
//         unit,
//       })

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       console.log("✅ File uploaded successfully:", result)

//       // Update the specification value with the file URL
//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("❌ File upload failed:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>
//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />
//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}
//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     return (
//       <div className="space-y-4">
//         <p className="text-sm text-gray-600">Station documents will be managed in the Instructions tab.</p>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               // Station document props
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }


















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       console.log("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       console.log("✅ Stations loaded:", stations.length)
//     } catch (error) {
//       console.error("❌ Failed to load stations:", error)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       console.log("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       console.log("✅ Enums loaded:", {
//         orderTypes: enumsData.orderTypes?.length || 0,
//         fileActions: enumsData.fileActions?.length || 0,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load enums:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       console.log("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       console.log("✅ Existing IDs loaded:", {
//         jobIds: jobIds.length,
//         assemblyIds: assemblyIds.length,
//         documentControlIds: documentControlIds.length,
//       })
//     } catch (error) {
//       console.error("❌ Failed to load existing IDs:", error)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       console.log("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()
//       console.log("📦 Checklist template loaded:", template)

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         console.log("✅ Processed checklist sections:", validSections.length)
//       } else {
//         console.warn("⚠️ Unexpected checklist template format:", template)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       console.error("❌ Failed to load checklist template:", error)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     console.log("📤 Station document upload (QUEUE MODE):", {
//       stationId,
//       fileName: file.name,
//       description,
//     })

//     try {
//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       console.log("✅ Station document queued successfully")
//     } catch (error) {
//       console.error("❌ Failed to queue station document:", error)
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))

//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     console.log("🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE")
//     console.log("📄 File:", file.name, file.size, "bytes")
//     console.log("📝 Description:", description)

//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       const finalDescription = description.trim() || file.name

//       console.log("💾 QUEUING document locally - NO UPLOAD YET...")

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         console.log("📋 Updated document queue:", updated.length, "documents")
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       console.log("✅ Document queued successfully - waiting for MPI creation")
//     } catch (error) {
//       console.error("❌ Document queue error:", error)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       console.log("🗑️ Document removed, updated list:", updated)
//       return updated
//     })

//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     console.log("\n🚀 === STARTING FORM SUBMISSION ===")
//     console.log("📝 Form data:", formData)
//     console.log("📋 Order form data:", orderFormData)
//     console.log("📋 Instructions:", instructions)
//     console.log("📄 MPI Documents in queue:", mpiDocumentation.length)
//     console.log(
//       "📁 Station Documents in queue:",
//       Object.keys(stationDocuments).reduce((total, stationId) => total + stationDocuments[stationId].length, 0),
//     )

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       console.error("❌ Validation failed:", validationErrors)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare checklist data to match backend expectations
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired // Only include required items
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     // Prepare stations data to match backend expectations
//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     // Prepare order forms data to match backend expectations
//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     // Prepare instructions data to match backend expectations (backend expects 'Instruction' not 'instructions')
//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     // Build the submission data step by step to ensure it's properly structured
//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     // Add optional fields only if they have values
//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     // Add uploaded documents to submission data
//     if (mpiDocumentation.length > 0) {
//       const uploadedDocs = mpiDocumentation
//         .filter((doc) => doc.isUploaded && doc.fileUrl)
//         .map((doc) => ({
//           fileUrl: doc.fileUrl,
//           description: doc.description,
//         }))

//       if (uploadedDocs.length > 0) {
//         submitData.mpiDocs = uploadedDocs
//       }
//     }

//     // DO NOT include stationMpiDocuments in the initial MPI creation
//     // We'll handle station document uploads separately after MPI creation

//     console.log("📤 Final submission data (WITHOUT station documents):", {
//       jobId: submitData.jobId,
//       assemblyId: submitData.assemblyId,
//       customer: submitData.customer,
//       instructionsCount: submitData.Instruction?.length || 0,
//       stationsCount: submitData.stations?.length || 0,
//       checklistsCount: submitData.checklists?.length || 0,
//       mpiDocsCount: submitData.mpiDocs?.length || 0,
//       orderFormsIncluded: !!submitData.orderForms,
//       stationDocumentsToUploadAfter: Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       ),
//     })

//     // Add debugging before submission
//     console.log("\n🚀 === MPI CREATION DEBUG START ===")
//     console.log("📝 Basic Info:", {
//       jobId: submitData.jobId,
//       assemblyId: submitData.assemblyId,
//       customer: submitData.customer,
//     })
//     console.log("📋 Instructions:", submitData.Instruction?.length || 0)
//     console.log("🏭 Stations:", submitData.stations?.length || 0)
//     console.log("📄 MPI Documents:", submitData.mpiDocs?.length || 0)

//     const totalDocs = Object.keys(stationDocuments).reduce(
//       (total, stationId) => total + stationDocuments[stationId].length,
//       0,
//     )

//     console.log("\n📁 === STATION DOCUMENT QUEUE ===")
//     console.log("📊 Total queued documents:", totalDocs)
//     Object.entries(stationDocuments).forEach(([stationId, docs]) => {
//       console.log(`🏭 Station ${stationId}:`, docs.length, "documents")
//       docs.forEach((doc, index) => {
//         console.log(`  📄 ${index + 1}. ${doc.description} (${doc.fileName})`)
//       })
//     })

//     try {
//       console.log("🚀 STEP 1: Creating MPI first (WITHOUT station documents)...")
//       const result = await onSubmit(submitData)
//       console.log("✅ STEP 1 COMPLETE: MPI created successfully:", result)

//       // Enhanced MPI ID extraction with debugging
//       console.log("\n✅ === MPI CREATION RESULT ===")
//       console.log("🆔 MPI ID extraction attempts:")
//       console.log("  - result.id:", result?.id)
//       console.log("  - result.mpiId:", result?.mpiId)
//       console.log("  - result.data?.id:", result?.data?.id)
//       console.log("  - result.data?.mpiId:", result?.data?.mpiId)

//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       console.log("🎯 Final extracted MPI ID:", mpiId)

//       if (!mpiId) {
//         console.error("❌ CRITICAL: No MPI ID could be extracted!")
//         console.error("❌ Full result object:", JSON.stringify(result, null, 2))
//       }

//       // STEP 2: Upload MPI documents ONLY AFTER MPI creation succeeds
//       const mpiDocUploadResults = { uploaded: 0, failed: 0 }

//       if (mpiDocumentation.length > 0 && mpiId) {
//         console.log(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               console.log(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)

//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)

//               console.log(`✅ MPI Document ${index + 1} uploaded successfully: ${doc.description}`)
//               mpiDocUploadResults.uploaded++
//             } catch (uploadError) {
//               console.error(`❌ Failed to upload MPI document ${index + 1} (${doc.description}):`, uploadError)
//               mpiDocUploadResults.failed++
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents ONLY AFTER MPI creation succeeds
//       const stationDocUploadResults = { uploaded: 0, failed: 0 }

//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0 && mpiId) {
//         console.log(`🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           console.log(`📁 Processing ${docs.length} documents for station ${stationId}`)

//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               console.log(`\n📤 === UPLOADING STATION DOCUMENT ${index + 1}/${docs.length} ===`)
//               console.log("🏭 Station ID:", stationId)
//               console.log("🆔 MPI ID:", mpiId)
//               console.log("📄 Document:", {
//                 description: doc.description,
//                 fileName: doc.fileName,
//                 fileSize: doc.file?.size,
//               })

//               try {
//                 // Create FormData for the upload
//                 const formData = new FormData()
//                 formData.append("files", doc.file)
//                 formData.append("stationId", stationId)
//                 formData.append("description", doc.description)
//                 formData.append("mpiId", mpiId)
//                 formData.append("originalName", doc.fileName)

//                 console.log("📤 Sending station document upload request...")

//                 const response = await fetch(`${API_BASE_URL}/station-mpi-documents/upload`, {
//                   method: "POST",
//                   body: formData,
//                 })

//                 console.log("📥 Upload response status:", response.status)

//                 if (!response.ok) {
//                   const errorText = await response.text()
//                   console.error("❌ Upload failed:", errorText)
//                   throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`)
//                 }

//                 const uploadResult = await response.json()
//                 console.log("✅ Station document uploaded successfully:", uploadResult)

//                 // IMPROVED ERROR HANDLING - Verify the document was properly linked
//                 const document = Array.isArray(uploadResult) ? uploadResult[0] : uploadResult

//                 if (!document.mpiId) {
//                   console.warn("⚠️ Document uploaded but MPI ID is null - this may be a backend issue:", {
//                     documentId: document.id,
//                     expectedMpiId: mpiId,
//                     actualMpiId: document.mpiId,
//                     stationId: document.stationId,
//                     uploadedSuccessfully: true,
//                     description: doc.description,
//                     fileName: doc.fileName,
//                   })

//                   // Still count as successful since the document was uploaded
//                   console.log("✅ Document uploaded successfully despite MPI ID issue - continuing...")
//                 } else if (document.mpiId !== mpiId) {
//                   console.warn("⚠️ Document MPI ID mismatch:", {
//                     expected: mpiId,
//                     actual: document.mpiId,
//                     documentId: document.id,
//                     stationId: document.stationId,
//                     description: doc.description,
//                     fileName: doc.fileName,
//                   })

//                   // This could be a serious issue - log it but continue
//                   console.log("⚠️ Continuing despite MPI ID mismatch - document was uploaded")
//                 } else {
//                   console.log("✅ Document properly linked to MPI:", document.mpiId)
//                 }

//                 stationDocUploadResults.uploaded++
//               } catch (uploadError) {
//                 console.error(`❌ Failed to upload station document ${index + 1}:`, uploadError)
//                 console.error("❌ Error details:", {
//                   message: uploadError.message,
//                   stationId,
//                   fileName: doc.fileName,
//                   description: doc.description,
//                 })

//                 stationDocUploadResults.failed++
//               }
//             }
//           }
//         }

//         console.log(
//           `📊 Station document upload complete: ${stationDocUploadResults.uploaded} uploaded, ${stationDocUploadResults.failed} failed`,
//         )
//       } else if (totalStationDocs > 0 && !mpiId) {
//         console.error(`❌ Cannot upload ${totalStationDocs} station documents - MPI ID not available`)
//         console.error("❌ MPI creation result:", result)
//       }

//       // Final summary with debugging
//       console.log("\n📊 === FINAL UPLOAD SUMMARY ===")
//       console.log("📄 MPI Documents:", {
//         uploaded: mpiDocUploadResults.uploaded,
//         failed: mpiDocUploadResults.failed,
//       })
//       console.log("📁 Station Documents:", {
//         uploaded: stationDocUploadResults.uploaded,
//         failed: stationDocUploadResults.failed,
//       })
//       console.log("🎯 Total Success:", mpiDocUploadResults.uploaded + stationDocUploadResults.uploaded)
//       console.log("❌ Total Failed:", mpiDocUploadResults.failed + stationDocUploadResults.failed)

//       // Final success message
//       const totalUploaded = mpiDocUploadResults.uploaded + stationDocUploadResults.uploaded
//       const totalFailed = mpiDocUploadResults.failed + stationDocUploadResults.failed

//       console.log(`📊 Final upload summary:`)
//       console.log(`📊 MPI Documents: ${mpiDocUploadResults.uploaded} uploaded, ${mpiDocUploadResults.failed} failed`)
//       console.log(
//         `📊 Station Documents: ${stationDocUploadResults.uploaded} uploaded, ${stationDocUploadResults.failed} failed`,
//       )
//       console.log(`📊 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: `MPI created successfully. ${totalUploaded} documents uploaded, ${totalFailed} failed.`,
//           variant: "destructive",
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       console.error("❌ STEP 1 FAILED: MPI creation error:", error)
//       console.error("❌ Error details:", {
//         message: error.message,
//         stack: error.stack,
//         name: error.name,
//       })

//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists. Please use a different Document Control ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists. Please use a different Job ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists. Please use a different Assembly ID.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       console.log("📤 Uploading specification file:", {
//         specificationId,
//         stationId,
//         fileName: file.name,
//         unit,
//       })

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       console.log("✅ File uploaded successfully:", result)

//       // Update the specification value with the file URL
//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       console.error("❌ File upload failed:", error)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>

//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>

//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />

//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}

//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />

//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     return (
//       <div className="space-y-4">
//         <p className="text-sm text-gray-600">Station documents will be managed in the Instructions tab.</p>
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               // Station document props
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }














// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])

//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Debug state
//   const [debugLogs, setDebugLogs] = useState<string[]>([])
//   const [showDebugLogs, setShowDebugLogs] = useState(false)

//   const addDebugLog = (message: string) => {
//     const timestamp = new Date().toLocaleTimeString()
//     const logMessage = `[${timestamp}] ${message}`
//     console.log(logMessage)
//     setDebugLogs((prev) => [...prev, logMessage])
//   }

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       addDebugLog("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       addDebugLog(`✅ Stations loaded: ${stations.length}`)
//     } catch (error) {
//       addDebugLog(`❌ Failed to load stations: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       addDebugLog("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       addDebugLog(
//         `✅ Enums loaded: orderTypes=${enumsData.orderTypes?.length || 0}, fileActions=${enumsData.fileActions?.length || 0}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load enums: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       addDebugLog("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       addDebugLog(
//         `✅ Existing IDs loaded: jobIds=${jobIds.length}, assemblyIds=${assemblyIds.length}, documentControlIds=${documentControlIds.length}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load existing IDs: ${error.message}`)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       addDebugLog("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         addDebugLog(`✅ Processed checklist sections: ${validSections.length}`)
//       } else {
//         addDebugLog(`⚠️ Unexpected checklist template format`)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       addDebugLog(`❌ Failed to load checklist template: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     addDebugLog(
//       `📤 Station document upload (QUEUE MODE): stationId=${stationId}, fileName=${file.name}, description=${description}`,
//     )

//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       addDebugLog(`✅ Station document queued successfully`)

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       addDebugLog(`❌ Failed to queue station document: ${error.message}`)
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     addDebugLog(
//       `🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE: fileName=${file.name}, description=${description}`,
//     )

//     setUploadingMpiDoc(true)

//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       addDebugLog(`💾 QUEUING document locally - NO UPLOAD YET...`)

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         addDebugLog(`📋 Updated document queue: ${updated.length} documents`)
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       addDebugLog(`✅ Document queued successfully - waiting for MPI creation`)
//     } catch (error) {
//       addDebugLog(`❌ Document queue error: ${error.message}`)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       addDebugLog(`🗑️ Document removed, updated list: ${updated.length}`)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     addDebugLog(`\n📤 === UPLOADING STATION DOCUMENT ${docIndex + 1} ===`)
//     addDebugLog(`🏭 Station ID: ${stationId}`)
//     addDebugLog(`🆔 MPI ID: ${mpiId}`)
//     addDebugLog(`📄 Document: ${doc.description} (${doc.fileName})`)
//     addDebugLog(`📊 File size: ${doc.file?.size} bytes`)

//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData with detailed logging
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       addDebugLog(`📦 FormData created with:`)
//       addDebugLog(`  - files: ${doc.file.name} (${doc.file.size} bytes)`)
//       addDebugLog(`  - stationId: ${stationId}`)
//       addDebugLog(`  - description: ${doc.description}`)
//       addDebugLog(`  - mpiId: ${mpiId}`)
//       addDebugLog(`  - originalName: ${doc.fileName}`)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`
//       addDebugLog(`📤 Sending POST request to: ${uploadUrl}`)

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       addDebugLog(`📥 Response status: ${response.status} ${response.statusText}`)

//       if (!response.ok) {
//         const errorText = await response.text()
//         addDebugLog(`❌ Response error text: ${errorText}`)
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()
//       addDebugLog(`✅ Upload successful! Result:`)
//       addDebugLog(`  - Document ID: ${uploadResult[0]?.id || "N/A"}`)
//       addDebugLog(`  - Station ID: ${uploadResult[0]?.stationId || "N/A"}`)
//       addDebugLog(`  - MPI ID: ${uploadResult[0]?.mpiId || "N/A"}`)
//       addDebugLog(`  - File URL: ${uploadResult[0]?.fileUrl || "N/A"}`)

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       addDebugLog(`❌ Upload failed: ${error.message}`)

//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))

//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     addDebugLog(`\n🚀 === STARTING FORM SUBMISSION ===`)
//     addDebugLog(
//       `📝 Form data: jobId=${formData.jobId}, assemblyId=${formData.assemblyId}, customer=${formData.customer}`,
//     )
//     addDebugLog(`📋 Order form data: ${JSON.stringify(orderFormData)}`)
//     addDebugLog(`📋 Instructions: ${instructions.length}`)
//     addDebugLog(`📄 MPI Documents in queue: ${mpiDocumentation.length}`)

//     const totalStationDocs = Object.keys(stationDocuments).reduce(
//       (total, stationId) => total + stationDocuments[stationId].length,
//       0,
//     )
//     addDebugLog(`📁 Station Documents in queue: ${totalStationDocs}`)

//     // Log station documents details
//     Object.entries(stationDocuments).forEach(([stationId, docs]) => {
//       addDebugLog(`  🏭 Station ${stationId}: ${docs.length} documents`)
//       docs.forEach((doc, index) => {
//         addDebugLog(`    📄 ${index + 1}. ${doc.description} (${doc.fileName}) - ${doc.file?.size} bytes`)
//       })
//     })

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       addDebugLog(`❌ Validation failed: ${validationErrors.join(", ")}`)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data (same as before)
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     addDebugLog(`📤 Final submission data prepared`)

//     try {
//       addDebugLog(`🚀 STEP 1: Creating MPI...`)
//       const result = await onSubmit(submitData)
//       addDebugLog(`✅ STEP 1 COMPLETE: MPI created successfully`)
//       addDebugLog(`📊 MPI Result: ${JSON.stringify(result, null, 2)}`)

//       // Enhanced MPI ID extraction with detailed debugging
//       addDebugLog(`\n🔍 === MPI ID EXTRACTION ===`)
//       addDebugLog(`  - result.id: ${result?.id}`)
//       addDebugLog(`  - result.mpiId: ${result?.mpiId}`)
//       addDebugLog(`  - result.data?.id: ${result?.data?.id}`)
//       addDebugLog(`  - result.data?.mpiId: ${result?.data?.mpiId}`)

//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       addDebugLog(`🎯 Final extracted MPI ID: ${mpiId}`)

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         addDebugLog(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               addDebugLog(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               addDebugLog(`✅ MPI Document ${index + 1} uploaded successfully`)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               addDebugLog(`❌ Failed to upload MPI document ${index + 1}: ${uploadError.message}`)
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents with detailed debugging
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }

//       if (totalStationDocs > 0) {
//         addDebugLog(`\n🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)
//         addDebugLog(`📊 Station documents breakdown:`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           addDebugLog(`\n📁 Processing ${docs.length} documents for station ${stationId}`)

//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//                 addDebugLog(`✅ Station document ${index + 1} uploaded successfully`)
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//                 addDebugLog(`❌ Station document ${index + 1} failed: ${uploadError.message}`)
//               }
//             }
//           }
//         }

//         addDebugLog(
//           `\n📊 Station document upload complete: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`,
//         )
//       } else {
//         addDebugLog(`📁 No station documents to upload`)
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       addDebugLog(`\n📊 === FINAL SUMMARY ===`)
//       addDebugLog(`📄 MPI Documents: ${mpiDocResults.uploaded} uploaded, ${mpiDocResults.failed} failed`)
//       addDebugLog(`📁 Station Documents: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`)
//       addDebugLog(`🎯 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         addDebugLog(`⚠️ Some uploads failed`)
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         addDebugLog(`✅ All uploads successful`)
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         addDebugLog(`✅ MPI created without documents`)
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       addDebugLog(`❌ MPI creation failed: ${error.message}`)

//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       addDebugLog(
//         `📤 Uploading specification file: specId=${specificationId}, stationId=${stationId}, fileName=${file.name}`,
//       )

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)
//       addDebugLog(`✅ Specification file uploaded successfully`)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       addDebugLog(`❌ Specification file upload failed: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>

//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />

//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}

//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     const docs = stationDocuments[station.id] || []

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents</h4>
//           <span className="text-sm text-gray-500">{docs.length} document(s) queued</span>
//         </div>

//         {docs.length > 0 && (
//           <div className="space-y-2">
//             {docs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* Debug Panel */}
//         <Card className="border shadow-sm">
//           <CardContent className="p-4">
//             <div className="flex items-center justify-between mb-4">
//               <h3 className="font-medium">Debug Information</h3>
//               <Button type="button" variant="outline" size="sm" onClick={() => setShowDebugLogs(!showDebugLogs)}>
//                 {showDebugLogs ? "Hide" : "Show"} Debug Logs ({debugLogs.length})
//               </Button>
//             </div>

//             {showDebugLogs && (
//               <div className="space-y-2">
//                 <div className="max-h-60 overflow-y-auto bg-gray-50 p-3 rounded text-xs font-mono">
//                   {debugLogs.map((log, index) => (
//                     <div key={index} className="mb-1">
//                       {log}
//                     </div>
//                   ))}
//                 </div>
//                 <Button type="button" variant="outline" size="sm" onClick={() => setDebugLogs([])}>
//                   Clear Logs
//                 </Button>
//               </div>
//             )}

//             {/* Quick Stats */}
//             <div className="grid grid-cols-4 gap-4 mt-4 text-sm">
//               <div className="text-center">
//                 <div className="font-medium">{mpiDocumentation.length}</div>
//                 <div className="text-gray-500">MPI Docs</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">
//                   {Object.keys(stationDocuments).reduce(
//                     (total, stationId) => total + stationDocuments[stationId].length,
//                     0,
//                   )}
//                 </div>
//                 <div className="text-gray-500">Station Docs</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{formData.selectedStationIds.length}</div>
//                 <div className="text-gray-500">Stations</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{instructions.filter((i) => i.trim()).length}</div>
//                 <div className="text-gray-500">Instructions</div>
//               </div>
//             </div>
//           </CardContent>
//         </Card>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }




















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<UploadedStationDocument[]>([])
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])

//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Debug state
//   const [debugLogs, setDebugLogs] = useState<string[]>([])
//   const [showDebugLogs, setShowDebugLogs] = useState(false)

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   const addDebugLog = (message: string) => {
//     const timestamp = new Date().toLocaleTimeString()
//     const logMessage = `[${timestamp}] ${message}`
//     console.log(logMessage)
//     setDebugLogs((prev) => [...prev, logMessage])
//   }

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       addDebugLog("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       addDebugLog(`✅ Stations loaded: ${stations.length}`)
//     } catch (error) {
//       addDebugLog(`❌ Failed to load stations: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       addDebugLog("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       addDebugLog(
//         `✅ Enums loaded: orderTypes=${enumsData.orderTypes?.length || 0}, fileActions=${enumsData.fileActions?.length || 0}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load enums: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       addDebugLog("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       addDebugLog(
//         `✅ Existing IDs loaded: jobIds=${jobIds.length}, assemblyIds=${assemblyIds.length}, documentControlIds=${documentControlIds.length}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load existing IDs: ${error.message}`)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       addDebugLog("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         addDebugLog(`✅ Processed checklist sections: ${validSections.length}`)
//       } else {
//         addDebugLog(`⚠️ Unexpected checklist template format`)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       addDebugLog(`❌ Failed to load checklist template: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string) => {
//     try {
//       setRefreshingData(true)
//       addDebugLog(`🔄 Loading uploaded station documents for MPI: ${mpiId}`)

//       const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-mpi/${mpiId}`, {
//         method: "GET",
//         headers: {
//           "Content-Type": "application/json",
//         },
//       })

//       if (!response.ok) {
//         throw new Error(`Failed to fetch station documents: ${response.status}`)
//       }

//       const documents = await response.json()
//       addDebugLog(`✅ Loaded ${documents.length} uploaded station documents`)

//       setUploadedStationDocuments(documents)

//       // Show success message with document count
//       if (documents.length > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${documents.length} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       addDebugLog(`❌ Failed to load uploaded station documents: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       setRefreshingData(false)
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     addDebugLog(
//       `📤 Station document upload (QUEUE MODE): stationId=${stationId}, fileName=${file.name}, description=${description}`,
//     )

//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       addDebugLog(`✅ Station document queued successfully`)

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       addDebugLog(`❌ Failed to queue station document: ${error.message}`)
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     addDebugLog(
//       `🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE: fileName=${file.name}, description=${description}`,
//     )

//     setUploadingMpiDoc(true)

//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       addDebugLog(`💾 QUEUING document locally - NO UPLOAD YET...`)

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         addDebugLog(`📋 Updated document queue: ${updated.length} documents`)
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       addDebugLog(`✅ Document queued successfully - waiting for MPI creation`)
//     } catch (error) {
//       addDebugLog(`❌ Document queue error: ${error.message}`)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       addDebugLog(`🗑️ Document removed, updated list: ${updated.length}`)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     addDebugLog(`\n📤 === UPLOADING STATION DOCUMENT ${docIndex + 1} ===`)
//     addDebugLog(`🏭 Station ID: ${stationId}`)
//     addDebugLog(`🆔 MPI ID: ${mpiId}`)
//     addDebugLog(`📄 Document: ${doc.description} (${doc.fileName})`)
//     addDebugLog(`📊 File size: ${doc.file?.size} bytes`)

//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData with detailed logging
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       addDebugLog(`📦 FormData created with:`)
//       addDebugLog(`  - files: ${doc.file.name} (${doc.file.size} bytes)`)
//       addDebugLog(`  - stationId: ${stationId}`)
//       addDebugLog(`  - description: ${doc.description}`)
//       addDebugLog(`  - mpiId: ${mpiId}`)
//       addDebugLog(`  - originalName: ${doc.fileName}`)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`
//       addDebugLog(`📤 Sending POST request to: ${uploadUrl}`)

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       addDebugLog(`📥 Response status: ${response.status} ${response.statusText}`)

//       if (!response.ok) {
//         const errorText = await response.text()
//         addDebugLog(`❌ Response error text: ${errorText}`)
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()
//       addDebugLog(`✅ Upload successful! Result:`)
//       addDebugLog(`  - Document ID: ${uploadResult[0]?.id || "N/A"}`)
//       addDebugLog(`  - Station ID: ${uploadResult[0]?.stationId || "N/A"}`)
//       addDebugLog(`  - MPI ID: ${uploadResult[0]?.mpiId || "N/A"}`)
//       addDebugLog(`  - File URL: ${uploadResult[0]?.fileUrl || "N/A"}`)

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       addDebugLog(`❌ Upload failed: ${error.message}`)

//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))

//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     addDebugLog(`\n🚀 === STARTING FORM SUBMISSION ===`)
//     addDebugLog(
//       `📝 Form data: jobId=${formData.jobId}, assemblyId=${formData.assemblyId}, customer=${formData.customer}`,
//     )
//     addDebugLog(`📋 Order form data: ${JSON.stringify(orderFormData)}`)
//     addDebugLog(`📋 Instructions: ${instructions.length}`)
//     addDebugLog(`📄 MPI Documents in queue: ${mpiDocumentation.length}`)

//     const totalStationDocs = Object.keys(stationDocuments).reduce(
//       (total, stationId) => total + stationDocuments[stationId].length,
//       0,
//     )
//     addDebugLog(`📁 Station Documents in queue: ${totalStationDocs}`)

//     // Log station documents details
//     Object.entries(stationDocuments).forEach(([stationId, docs]) => {
//       addDebugLog(`  🏭 Station ${stationId}: ${docs.length} documents`)
//       docs.forEach((doc, index) => {
//         addDebugLog(`    📄 ${index + 1}. ${doc.description} (${doc.fileName}) - ${doc.file?.size} bytes`)
//       })
//     })

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       addDebugLog(`❌ Validation failed: ${validationErrors.join(", ")}`)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data (same as before)
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     addDebugLog(`📤 Final submission data prepared`)

//     try {
//       addDebugLog(`🚀 STEP 1: Creating MPI...`)
//       const result = await onSubmit(submitData)
//       addDebugLog(`✅ STEP 1 COMPLETE: MPI created successfully`)
//       addDebugLog(`📊 MPI Result: ${JSON.stringify(result, null, 2)}`)

//       // Enhanced MPI ID extraction with detailed debugging
//       addDebugLog(`\n🔍 === MPI ID EXTRACTION ===`)
//       addDebugLog(`  - result.id: ${result?.id}`)
//       addDebugLog(`  - result.mpiId: ${result?.mpiId}`)
//       addDebugLog(`  - result.data?.id: ${result?.data?.id}`)
//       addDebugLog(`  - result.data?.mpiId: ${result?.data?.mpiId}`)

//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       addDebugLog(`🎯 Final extracted MPI ID: ${mpiId}`)

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         addDebugLog(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               addDebugLog(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               addDebugLog(`✅ MPI Document ${index + 1} uploaded successfully`)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               addDebugLog(`❌ Failed to upload MPI document ${index + 1}: ${uploadError.message}`)
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents with detailed debugging
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }

//       if (totalStationDocs > 0) {
//         addDebugLog(`\n🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)
//         addDebugLog(`📊 Station documents breakdown:`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           addDebugLog(`\n📁 Processing ${docs.length} documents for station ${stationId}`)

//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//                 addDebugLog(`✅ Station document ${index + 1} uploaded successfully`)
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//                 addDebugLog(`❌ Station document ${index + 1} failed: ${uploadError.message}`)
//               }
//             }
//           }
//         }

//         addDebugLog(
//           `\n📊 Station document upload complete: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`,
//         )

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           addDebugLog(`🔄 STEP 4: Refreshing uploaded documents display...`)
//           await loadUploadedStationDocuments(mpiId)
//         }
//       } else {
//         addDebugLog(`📁 No station documents to upload`)
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       addDebugLog(`\n📊 === FINAL SUMMARY ===`)
//       addDebugLog(`📄 MPI Documents: ${mpiDocResults.uploaded} uploaded, ${mpiDocResults.failed} failed`)
//       addDebugLog(`📁 Station Documents: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`)
//       addDebugLog(`🎯 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         addDebugLog(`⚠️ Some uploads failed`)
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         addDebugLog(`✅ All uploads successful`)
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         addDebugLog(`✅ MPI created without documents`)
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       addDebugLog(`❌ MPI creation failed: ${error.message}`)

//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       addDebugLog(
//         `📤 Uploading specification file: specId=${specificationId}, stationId=${stationId}, fileName=${file.name}`,
//       )

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)
//       addDebugLog(`✅ Specification file uploaded successfully`)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       addDebugLog(`❌ Specification file upload failed: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>

//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />

//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}

//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     const uploadedDocs = uploadedStationDocuments.filter((doc) => doc.stationId === station.id)

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents</h4>
//           <div className="flex items-center gap-2">
//             {refreshingData && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">Uploaded: {new Date(doc.createdAt).toLocaleString()}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId)}
//             disabled={refreshingData}
//             className="w-full"
//           >
//             {refreshingData ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh Uploaded Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* Debug Panel */}
//         <Card className="border shadow-sm">
//           <CardContent className="p-4">
//             <div className="flex items-center justify-between mb-4">
//               <h3 className="font-medium">Debug Information</h3>
//               <Button type="button" variant="outline" size="sm" onClick={() => setShowDebugLogs(!showDebugLogs)}>
//                 {showDebugLogs ? "Hide" : "Show"} Debug Logs ({debugLogs.length})
//               </Button>
//             </div>

//             {showDebugLogs && (
//               <div className="space-y-2">
//                 <div className="max-h-60 overflow-y-auto bg-gray-50 p-3 rounded text-xs font-mono">
//                   {debugLogs.map((log, index) => (
//                     <div key={index} className="mb-1">
//                       {log}
//                     </div>
//                   ))}
//                 </div>
//                 <Button type="button" variant="outline" size="sm" onClick={() => setDebugLogs([])}>
//                   Clear Logs
//                 </Button>
//               </div>
//             )}

//             {/* Quick Stats */}
//             <div className="grid grid-cols-5 gap-4 mt-4 text-sm">
//               <div className="text-center">
//                 <div className="font-medium">{mpiDocumentation.length}</div>
//                 <div className="text-gray-500">MPI Docs</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">
//                   {Object.keys(stationDocuments).reduce(
//                     (total, stationId) => total + stationDocuments[stationId].length,
//                     0,
//                   )}
//                 </div>
//                 <div className="text-gray-500">Queued</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{uploadedStationDocuments.length}</div>
//                 <div className="text-gray-500">Uploaded</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{formData.selectedStationIds.length}</div>
//                 <div className="text-gray-500">Stations</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{instructions.filter((i) => i.trim()).length}</div>
//                 <div className="text-gray-500">Instructions</div>
//               </div>
//             </div>

//             {/* MPI ID Display */}
//             {createdMpiId && (
//               <Alert className="mt-4">
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             )}
//           </CardContent>
//         </Card>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }


















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])

//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())

//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Debug state
//   const [debugLogs, setDebugLogs] = useState<string[]>([])
//   const [showDebugLogs, setShowDebugLogs] = useState(false)

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   const addDebugLog = (message: string) => {
//     const timestamp = new Date().toLocaleTimeString()
//     const logMessage = `[${timestamp}] ${message}`
//     console.log(logMessage)
//     setDebugLogs((prev) => [...prev, logMessage])
//   }

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       addDebugLog("🏭 Loading stations...")
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//       addDebugLog(`✅ Stations loaded: ${stations.length}`)
//     } catch (error) {
//       addDebugLog(`❌ Failed to load stations: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       addDebugLog("📋 Loading enums...")
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//       addDebugLog(
//         `✅ Enums loaded: orderTypes=${enumsData.orderTypes?.length || 0}, fileActions=${enumsData.fileActions?.length || 0}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load enums: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       addDebugLog("🔍 Loading existing IDs for validation...")
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)

//       addDebugLog(
//         `✅ Existing IDs loaded: jobIds=${jobIds.length}, assemblyIds=${assemblyIds.length}, documentControlIds=${documentControlIds.length}`,
//       )
//     } catch (error) {
//       addDebugLog(`❌ Failed to load existing IDs: ${error.message}`)
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       addDebugLog("📋 Loading checklist template...")
//       const template = await MPIAPI.getChecklistTemplate()

//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//         addDebugLog(`✅ Processed checklist sections: ${validSections.length}`)
//       } else {
//         addDebugLog(`⚠️ Unexpected checklist template format`)
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       addDebugLog(`❌ Failed to load checklist template: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         addDebugLog(`🔄 Loading uploaded documents for station: ${stationId}, MPI: ${mpiId}`)

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             addDebugLog(`📄 No uploaded documents found for station: ${stationId}`)
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()
//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         addDebugLog(`✅ Loaded ${filteredDocs.length} uploaded documents for station: ${stationId}`)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       addDebugLog(`❌ Failed to load uploaded station documents: ${error.message}`)
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     addDebugLog(
//       `📤 Station document upload (QUEUE MODE): stationId=${stationId}, fileName=${file.name}, description=${description}`,
//     )

//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       addDebugLog(`✅ Station document queued successfully`)

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       addDebugLog(`❌ Failed to queue station document: ${error.message}`)
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     addDebugLog(
//       `🔄 handleMpiDocumentUpload called - QUEUE ONLY MODE: fileName=${file.name}, description=${description}`,
//     )

//     setUploadingMpiDoc(true)

//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       addDebugLog(`💾 QUEUING document locally - NO UPLOAD YET...`)

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         addDebugLog(`📋 Updated document queue: ${updated.length} documents`)
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })

//       addDebugLog(`✅ Document queued successfully - waiting for MPI creation`)
//     } catch (error) {
//       addDebugLog(`❌ Document queue error: ${error.message}`)
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       addDebugLog(`🗑️ Document removed, updated list: ${updated.length}`)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     addDebugLog(`\n📤 === UPLOADING STATION DOCUMENT ${docIndex + 1} ===`)
//     addDebugLog(`🏭 Station ID: ${stationId}`)
//     addDebugLog(`🆔 MPI ID: ${mpiId}`)
//     addDebugLog(`📄 Document: ${doc.description} (${doc.fileName})`)
//     addDebugLog(`📊 File size: ${doc.file?.size} bytes`)

//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData with detailed logging
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       addDebugLog(`📦 FormData created with:`)
//       addDebugLog(`  - files: ${doc.file.name} (${doc.file.size} bytes)`)
//       addDebugLog(`  - stationId: ${stationId}`)
//       addDebugLog(`  - description: ${doc.description}`)
//       addDebugLog(`  - mpiId: ${mpiId}`)
//       addDebugLog(`  - originalName: ${doc.fileName}`)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`
//       addDebugLog(`📤 Sending POST request to: ${uploadUrl}`)

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       addDebugLog(`📥 Response status: ${response.status} ${response.statusText}`)

//       if (!response.ok) {
//         const errorText = await response.text()
//         addDebugLog(`❌ Response error text: ${errorText}`)
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()
//       addDebugLog(`✅ Upload successful! Result:`)
//       addDebugLog(`  - Document ID: ${uploadResult[0]?.id || "N/A"}`)
//       addDebugLog(`  - Station ID: ${uploadResult[0]?.stationId || "N/A"}`)
//       addDebugLog(`  - MPI ID: ${uploadResult[0]?.mpiId || "N/A"}`)
//       addDebugLog(`  - File URL: ${uploadResult[0]?.fileUrl || "N/A"}`)

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       addDebugLog(`❌ Upload failed: ${error.message}`)

//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))

//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     addDebugLog(`\n🚀 === STARTING FORM SUBMISSION ===`)
//     addDebugLog(
//       `📝 Form data: jobId=${formData.jobId}, assemblyId=${formData.assemblyId}, customer=${formData.customer}`,
//     )
//     addDebugLog(`📋 Order form data: ${JSON.stringify(orderFormData)}`)
//     addDebugLog(`📋 Instructions: ${instructions.length}`)
//     addDebugLog(`📄 MPI Documents in queue: ${mpiDocumentation.length}`)

//     const totalStationDocs = Object.keys(stationDocuments).reduce(
//       (total, stationId) => total + stationDocuments[stationId].length,
//       0,
//     )
//     addDebugLog(`📁 Station Documents in queue: ${totalStationDocs}`)

//     // Log station documents details
//     Object.entries(stationDocuments).forEach(([stationId, docs]) => {
//       addDebugLog(`  🏭 Station ${stationId}: ${docs.length} documents`)
//       docs.forEach((doc, index) => {
//         addDebugLog(`    📄 ${index + 1}. ${doc.description} (${doc.fileName}) - ${doc.file?.size} bytes`)
//       })
//     })

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       addDebugLog(`❌ Validation failed: ${validationErrors.join(", ")}`)
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data (same as before)
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     addDebugLog(`📤 Final submission data prepared`)

//     try {
//       addDebugLog(`🚀 STEP 1: Creating MPI...`)
//       const result = await onSubmit(submitData)
//       addDebugLog(`✅ STEP 1 COMPLETE: MPI created successfully`)
//       addDebugLog(`📊 MPI Result: ${JSON.stringify(result, null, 2)}`)

//       // Enhanced MPI ID extraction with detailed debugging
//       addDebugLog(`\n🔍 === MPI ID EXTRACTION ===`)
//       addDebugLog(`  - result.id: ${result?.id}`)
//       addDebugLog(`  - result.mpiId: ${result?.mpiId}`)
//       addDebugLog(`  - result.data?.id: ${result?.data?.id}`)
//       addDebugLog(`  - result.data?.mpiId: ${result?.data?.mpiId}`)

//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       addDebugLog(`🎯 Final extracted MPI ID: ${mpiId}`)

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         addDebugLog(`🚀 STEP 2: Uploading ${mpiDocumentation.length} MPI documents...`)

//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               addDebugLog(`📤 Uploading MPI document ${index + 1}/${mpiDocumentation.length}: ${doc.description}`)
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               addDebugLog(`✅ MPI Document ${index + 1} uploaded successfully`)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               addDebugLog(`❌ Failed to upload MPI document ${index + 1}: ${uploadError.message}`)
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents with detailed debugging
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }

//       if (totalStationDocs > 0) {
//         addDebugLog(`\n🚀 STEP 3: Uploading ${totalStationDocs} station documents...`)
//         addDebugLog(`📊 Station documents breakdown:`)

//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           addDebugLog(`\n📁 Processing ${docs.length} documents for station ${stationId}`)

//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//                 addDebugLog(`✅ Station document ${index + 1} uploaded successfully`)
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//                 addDebugLog(`❌ Station document ${index + 1} failed: ${uploadError.message}`)
//               }
//             }
//           }
//         }

//         addDebugLog(
//           `\n📊 Station document upload complete: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`,
//         )

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           addDebugLog(`🔄 STEP 4: Refreshing uploaded documents display...`)
//           await loadUploadedStationDocuments(mpiId)
//         }
//       } else {
//         addDebugLog(`📁 No station documents to upload`)
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       addDebugLog(`\n📊 === FINAL SUMMARY ===`)
//       addDebugLog(`📄 MPI Documents: ${mpiDocResults.uploaded} uploaded, ${mpiDocResults.failed} failed`)
//       addDebugLog(`📁 Station Documents: ${stationDocResults.uploaded} uploaded, ${stationDocResults.failed} failed`)
//       addDebugLog(`🎯 Total: ${totalUploaded} uploaded, ${totalFailed} failed`)

//       if (totalFailed > 0) {
//         addDebugLog(`⚠️ Some uploads failed`)
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         addDebugLog(`✅ All uploads successful`)
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         addDebugLog(`✅ MPI created without documents`)
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       addDebugLog(`❌ MPI creation failed: ${error.message}`)

//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       addDebugLog(
//         `📤 Uploading specification file: specId=${specificationId}, stationId=${stationId}, fileName=${file.name}`,
//       )

//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)
//       addDebugLog(`✅ Specification file uploaded successfully`)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       addDebugLog(`❌ Specification file upload failed: ${error.message}`)
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>

//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />

//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}

//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}

//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}

//         {/* Debug Info for this station */}
//         {showDebugLogs && (
//           <div className="mt-2 p-2 bg-gray-100 rounded text-xs">
//             <strong>Debug - {station.stationName}:</strong>
//             <br />
//             Station ID: {station.id}
//             <br />
//             Queued: {queuedDocs.length} docs
//             <br />
//             Uploaded: {uploadedDocs.length} docs
//             <br />
//             Loading: {isLoadingDocs ? "Yes" : "No"}
//             <br />
//             MPI ID: {createdMpiId || "Not created"}
//           </div>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* Debug Panel */}
//         <Card className="border shadow-sm">
//           <CardContent className="p-4">
//             <div className="flex items-center justify-between mb-4">
//               <h3 className="font-medium">Debug Information</h3>
//               <Button type="button" variant="outline" size="sm" onClick={() => setShowDebugLogs(!showDebugLogs)}>
//                 {showDebugLogs ? "Hide" : "Show"} Debug Logs ({debugLogs.length})
//               </Button>
//             </div>

//             {showDebugLogs && (
//               <div className="space-y-2">
//                 <div className="max-h-60 overflow-y-auto bg-gray-50 p-3 rounded text-xs font-mono">
//                   {debugLogs.map((log, index) => (
//                     <div key={index} className="mb-1">
//                       {log}
//                     </div>
//                   ))}
//                 </div>
//                 <Button type="button" variant="outline" size="sm" onClick={() => setDebugLogs([])}>
//                   Clear Logs
//                 </Button>
//               </div>
//             )}

//             {/* Quick Stats */}
//             <div className="grid grid-cols-5 gap-4 mt-4 text-sm">
//               <div className="text-center">
//                 <div className="font-medium">{mpiDocumentation.length}</div>
//                 <div className="text-gray-500">MPI Docs</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">
//                   {Object.keys(stationDocuments).reduce(
//                     (total, stationId) => total + stationDocuments[stationId].length,
//                     0,
//                   )}
//                 </div>
//                 <div className="text-gray-500">Queued</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{Object.values(uploadedStationDocuments).flat().length}</div>
//                 <div className="text-gray-500">Uploaded</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{formData.selectedStationIds.length}</div>
//                 <div className="text-gray-500">Stations</div>
//               </div>
//               <div className="text-center">
//                 <div className="font-medium">{instructions.filter((i) => i.trim()).length}</div>
//                 <div className="text-gray-500">Instructions</div>
//               </div>
//             </div>

//             {/* MPI ID Display */}
//             {createdMpiId && (
//               <Alert className="mt-4">
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             )}
//           </CardContent>
//         </Card>

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }














// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     orderType: [] as string[],
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.orderType.length > 0
//         ? {
//             orderType: orderFormData.orderType,
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>
//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />
//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}
//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}
//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }




































// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     OrderType: [] as string[], // Changed from orderType to OrderType
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.OrderType.length > 0 // Changed from orderType to OrderType
//         ? {
//             OrderType: orderFormData.OrderType, // Changed from orderType to OrderType
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     return (
//       <div key={spec.id} className="space-y-3">
//         <div className="flex items-center justify-between">
//           <Label className="text-sm font-medium">
//             {spec.name}
//             {spec.required && <span className="text-red-500 ml-1">*</span>}
//           </Label>
//           {spec.inputType === "file" && specValue?.fileUrl && (
//             <div className="flex gap-2">
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => window.open(specValue.fileUrl, "_blank")}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Eye className="w-3 h-3 mr-1" />
//                 View
//               </Button>
//               <Button
//                 size="sm"
//                 variant="outline"
//                 onClick={() => {
//                   const link = document.createElement("a")
//                   link.href = specValue.fileUrl
//                   link.download = `${spec.name}-${stationId}`
//                   link.click()
//                 }}
//                 className="h-7 px-2 text-xs"
//               >
//                 <Download className="w-3 h-3 mr-1" />
//                 Download
//               </Button>
//             </div>
//           )}
//         </div>

//         {spec.inputType === "file" ? (
//           <div className="space-y-2">
//             <Input
//               type="file"
//               onChange={(e) => {
//                 const file = e.target.files?.[0]
//                 if (file) {
//                   handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                 }
//               }}
//               disabled={isUploading}
//               className="cursor-pointer"
//             />
//             {isUploading && (
//               <div className="flex items-center gap-2 text-sm text-blue-600">
//                 <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                 Uploading...
//               </div>
//             )}
//             {specValue?.fileUrl && (
//               <div className="text-sm text-green-600">
//                 <FileText className="w-4 h-4 inline mr-1" />
//                 File uploaded successfully
//               </div>
//             )}
//           </div>
//         ) : spec.inputType === "select" ? (
//           <Select
//             value={specValue?.value || ""}
//             onValueChange={(value) => handleSpecificationValueChange(spec.id, value, specValue?.unit)}
//           >
//             <SelectTrigger>
//               <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//             </SelectTrigger>
//             <SelectContent>
//               {spec.suggestions?.map((suggestion: string) => (
//                 <SelectItem key={suggestion} value={suggestion}>
//                   {suggestion}
//                 </SelectItem>
//               ))}
//             </SelectContent>
//           </Select>
//         ) : spec.inputType === "checkbox" ? (
//           <div className="flex items-center space-x-2">
//             <Checkbox
//               id={`spec-${spec.id}`}
//               checked={specValue?.value === "true"}
//               onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//             />
//             <Label htmlFor={`spec-${spec.id}`} className="text-sm">
//               {spec.name}
//             </Label>
//           </div>
//         ) : (
//           <div className="flex gap-2">
//             <Input
//               type={spec.inputType === "number" ? "number" : "text"}
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="flex-1"
//             />
//             {spec.inputType === "number" && (
//               <Input
//                 type="text"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 placeholder="Unit"
//                 className="w-20"
//               />
//             )}
//           </div>
//         )}
//         {spec.suggestions && spec.inputType !== "select" && spec.suggestions.length > 0 && (
//           <div className="text-xs text-gray-500">Suggestions: {spec.suggestions.join(", ")}</div>
//         )}
//       </div>
//     )
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     OrderType: [] as string[], // Changed from orderType to OrderType
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.OrderType.length > 0 // Changed from orderType to OrderType
//         ? {
//             OrderType: orderFormData.OrderType, // Changed from orderType to OrderType
//             ...(orderFormData.distributionDate && {
//               distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//             }),
//             ...(orderFormData.requiredBy && {
//               requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//             }),
//             ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//             ...(orderFormData.revision && { revision: orderFormData.revision }),
//             ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//             ...(orderFormData.fileAction.length > 0 && {
//               fileAction: orderFormData.fileAction,
//             }),
//             markComplete: orderFormData.markComplete,
//             ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//           }
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     // Use the same logic as the edit form
//     const inputType = spec.inputType || spec.type || "TEXT"

//     console.log(`🔍 Rendering specification input:`, {
//       specId: spec.id,
//       specName: spec.name,
//       inputType: inputType,
//       originalSpec: spec,
//     })

//     switch (inputType) {
//       case "TEXT":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex gap-2">
//               <Input
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div key={spec.id} className="space-y-3">
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//               {specValue?.fileUrl && (
//                 <div className="flex gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(specValue.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = specValue.fileUrl
//                       link.download = `${spec.name}-${stationId}`
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               )}
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }











// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     OrderType: [] as string[], // Changed from orderType to OrderType
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.OrderType.length > 0
//         ? [
//             {
//               // Make it an array with a single object
//               OrderType: orderFormData.OrderType,
//               ...(orderFormData.distributionDate && {
//                 distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//               }),
//               ...(orderFormData.requiredBy && {
//                 requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//               }),
//               ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//               ...(orderFormData.revision && { revision: orderFormData.revision }),
//               ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//               ...(orderFormData.fileAction.length > 0 && {
//                 fileAction: orderFormData.fileAction,
//               }),
//               markComplete: orderFormData.markComplete,
//               ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//             },
//           ]
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     // Use the same logic as the edit form
//     const inputType = spec.inputType || spec.type || "TEXT"

//     console.log(`🔍 Rendering specification input:`, {
//       specId: spec.id,
//       specName: spec.name,
//       inputType: inputType,
//       originalSpec: spec,
//     })

//     switch (inputType) {
//       case "TEXT":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex gap-2">
//               <Input
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div key={spec.id} className="space-y-3">
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//               {specValue?.fileUrl && (
//                 <div className="flex gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(specValue.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = specValue.fileUrl
//                       link.download = `${spec.name}-${stationId}`
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               )}
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }










// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     OrderType: [] as string[], // Changed from orderType to OrderType
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//     selectedServiceId: "", // Add this line
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.OrderType.length > 0
//         ? [
//             {
//               // Make it an array with a single object
//               OrderType: orderFormData.OrderType,
//               ...(orderFormData.distributionDate && {
//                 distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//               }),
//               ...(orderFormData.requiredBy && {
//                 requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//               }),
//               ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//               ...(orderFormData.revision && { revision: orderFormData.revision }),
//               ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//               ...(orderFormData.fileAction.length > 0 && {
//                 fileAction: orderFormData.fileAction,
//               }),
//               markComplete: orderFormData.markComplete,
//               ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//               // Add the selected service ID in the format the backend expects
//               ...(orderFormData.selectedServiceId && {
//                 serviceIds: [orderFormData.selectedServiceId],
//               }),
//             },
//           ]
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     // Use the same logic as the edit form
//     const inputType = spec.inputType || spec.type || "TEXT"

//     console.log(`🔍 Rendering specification input:`, {
//       specId: spec.id,
//       specName: spec.name,
//       inputType: inputType,
//       originalSpec: spec,
//     })

//     switch (inputType) {
//       case "TEXT":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex gap-2">
//               <Input
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div key={spec.id} className="space-y-3">
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//               {specValue?.fileUrl && (
//                 <div className="flex gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(specValue.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = specValue.fileUrl
//                       link.download = `${spec.name}-${stationId}`
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               )}
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-red-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-red-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }



















// "use client"

// import { SelectItem } from "@/components/ui/select"
// import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
// import type React from "react"
// import { useState, useEffect } from "react"
// import { Button } from "@/components/ui/button"
// import { Input } from "@/components/ui/input"
// import { Label } from "@/components/ui/label"
// import { Card, CardContent } from "@/components/ui/card"
// import { Checkbox } from "@/components/ui/checkbox"
// import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
// import type { CreateMPIDto } from "./types"
// import { StationAPI } from "../stations/station-api"
// import type { Station } from "../stations/types"
// import { useToast } from "@/hooks/use-toast"
// import { MPIAPI } from "./mpi-api"
// import { MPIFormTabs } from "./mpi-form-tabs"
// import { MPIDocumentationAPI } from "./mpi-document-api"
// import { MPIFormActions } from "./mpi-form-actions"
// import { MPIFormHeader } from "./mpi-form-header"
// import { API_BASE_URL } from "@/lib/constants"
// import { Alert, AlertDescription } from "@/components/ui/alert"

// interface MPIFormProps {
//   onSubmit: (data: CreateMPIDto) => Promise<any>
//   onCancel: () => void
//   isLoading?: boolean
// }

// interface SpecificationValue {
//   specificationId: string
//   value: string
//   fileUrl?: string
//   unit?: string
// }

// interface ChecklistSection {
//   id: string
//   name: string
//   description: string
//   items: ChecklistItem[]
// }

// interface ChecklistItem {
//   id: string
//   description: string
//   required: boolean
//   remarks: string
//   category?: string
//   isActive: boolean
//   createdBy: string
//   sectionId: string
// }

// interface MPIDocumentation {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   isUploaded?: boolean
// }

// interface StationDocument {
//   id?: string
//   file?: File
//   fileUrl?: string
//   description: string
//   fileName: string
//   stationId: string
//   isUploaded?: boolean
//   uploadError?: string
//   uploadStatus?: "pending" | "uploading" | "success" | "error"
// }

// interface UploadedStationDocument {
//   id: string
//   fileUrl: string
//   description: string
//   stationId: string
//   mpiId: string
//   createdAt: string
//   station?: {
//     id: string
//     name: string
//   }
// }

// export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
//   const [activeTab, setActiveTab] = useState("basic-info")
//   const [formData, setFormData] = useState({
//     jobId: "",
//     assemblyId: "",
//     customer: "",
//     selectedStationIds: [],
//   })

//   // Order Form State
//   const [orderFormData, setOrderFormData] = useState({
//     OrderType: [] as string[], // Changed from orderType to OrderType
//     distributionDate: "",
//     requiredBy: "",
//     internalOrderNumber: "",
//     revision: "",
//     otherAttachments: "",
//     fileAction: [] as string[],
//     markComplete: false,
//     documentControlId: "",
//     selectedServiceId: "",
//   })

//   // MPI Documentation State
//   const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
//   const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

//   // Station Documents State
//   const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
//   const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
//     {},
//   )
//   const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
//   const [availableStations, setAvailableStations] = useState<Station[]>([])
//   const [loadingStations, setLoadingStations] = useState(false)
//   const [selectedStations, setSelectedStations] = useState<Station[]>([])
//   const { toast } = useToast()

//   // Enums state
//   const [enums, setEnums] = useState<any>({})
//   const [loadingEnums, setLoadingEnums] = useState(false)

//   // Specification values state
//   const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
//   const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
//   const [existingJobIds, setExistingJobIds] = useState<string[]>([])
//   const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
//   const [checkingIds, setCheckingIds] = useState(false)
//   const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

//   // Checklist state
//   const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
//   const [loadingChecklist, setLoadingChecklist] = useState(false)
//   const [checklistData, setChecklistData] = useState<Record<string, any>>({})
//   const [checklistModifications, setChecklistModifications] = useState<
//     Record<string, { required: boolean; remarks: string }>
//   >({})

//   // Instructions state
//   const [instructions, setInstructions] = useState<string[]>([])
//   const [activeStationId, setActiveStationId] = useState<string | null>(null)
//   const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

//   // Post-upload state
//   const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
//   const [refreshingData, setRefreshingData] = useState(false)

//   useEffect(() => {
//     loadStations()
//     loadEnums()
//     loadExistingIds()
//     loadChecklistTemplate()
//   }, [])

//   useEffect(() => {
//     const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
//     setSelectedStations(selected)
//   }, [formData.selectedStationIds, availableStations])

//   // Load uploaded station documents when MPI is created
//   useEffect(() => {
//     if (createdMpiId && formData.selectedStationIds.length > 0) {
//       loadUploadedStationDocuments(createdMpiId)
//     }
//   }, [createdMpiId, formData.selectedStationIds])

//   const loadStations = async () => {
//     try {
//       setLoadingStations(true)
//       const stations = await StationAPI.getAllStations()
//       setAvailableStations(stations)
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to load stations. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingStations(false)
//     }
//   }

//   const loadEnums = async () => {
//     try {
//       setLoadingEnums(true)
//       const enumsData = await MPIAPI.getEnums()
//       setEnums(enumsData)
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load form options.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingEnums(false)
//     }
//   }

//   const loadExistingIds = async () => {
//     try {
//       setCheckingIds(true)
//       const mpis = await MPIAPI.getAllMPIs()
//       const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
//       const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
//       const documentControlIds = mpis
//         .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
//         .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
//         .filter(Boolean)
//         .map((id) => id.toLowerCase())

//       setExistingJobIds(jobIds)
//       setExistingAssemblyIds(assemblyIds)
//       setExistingDocumentControlIds(documentControlIds)
//     } catch (error) {
//       // Error handling without debug logging
//     } finally {
//       setCheckingIds(false)
//     }
//   }

//   const loadChecklistTemplate = async () => {
//     try {
//       setLoadingChecklist(true)
//       const template = await MPIAPI.getChecklistTemplate()
//       if (template && Array.isArray(template)) {
//         const validSections = template
//           .filter(
//             (section) =>
//               section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
//           )
//           .map((section, sectionIndex) => ({
//             id: `section-${sectionIndex}`,
//             name: section.name,
//             description: `${section.name} quality control items`,
//             items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
//               id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
//               description: item.description || "No description",
//               required: true,
//               remarks: "",
//               category: item.category || section.name,
//               isActive: item.isActive !== undefined ? item.isActive : true,
//               createdBy: item.createdBy || "System",
//               sectionId: `section-${sectionIndex}`,
//             })),
//           }))

//         setChecklistTemplate(validSections)
//       } else {
//         setChecklistTemplate([])
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load checklist template. Using default checklist.",
//         variant: "destructive",
//       })
//     } finally {
//       setLoadingChecklist(false)
//     }
//   }

//   const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
//     try {
//       // If specific station ID is provided, only load for that station
//       const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

//       for (const stationId of stationsToLoad) {
//         // Skip if already loading for this station
//         if (loadingUploadedDocs[stationId]) {
//           continue
//         }

//         setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

//         // Load documents for this specific station
//         const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
//           method: "GET",
//           headers: {
//             "Content-Type": "application/json",
//           },
//         })

//         if (!response.ok) {
//           if (response.status === 404) {
//             // No documents found for this station - that's okay
//             setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
//             continue
//           }
//           throw new Error(`Failed to fetch station documents: ${response.status}`)
//         }

//         const documents = await response.json()

//         // Filter to only include documents for this MPI
//         const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

//         setUploadedStationDocuments((prev) => ({
//           ...prev,
//           [stationId]: filteredDocs,
//         }))
//       }

//       // Show success message with total document count
//       const totalDocs = Object.values(uploadedStationDocuments).flat().length
//       if (totalDocs > 0) {
//         toast({
//           title: "📁 Documents Loaded",
//           description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
//           variant: "default",
//         })
//       }
//     } catch (error) {
//       toast({
//         title: "Warning",
//         description: "Failed to load uploaded station documents.",
//         variant: "destructive",
//       })
//     } finally {
//       // Clear loading states
//       setLoadingUploadedDocs((prev) => {
//         const newState = { ...prev }
//         const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
//         stationsToLoad.forEach((stationId) => {
//           newState[stationId] = false
//         })
//         return newState
//       })
//     }
//   }

//   const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
//     setChecklistModifications((prev) => ({
//       ...prev,
//       [itemId]: {
//         ...prev[itemId],
//         [field]: value,
//       },
//     }))
//   }

//   const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
//     return checklistModifications[itemId]?.[field] ?? defaultValue
//   }

//   // Instruction handlers
//   const handleAddInstruction = () => {
//     setInstructions((prev) => [...prev, ""])
//   }

//   const handleInstructionChange = (index: number, value: string) => {
//     setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
//   }

//   const handleRemoveInstruction = (index: number) => {
//     setInstructions((prev) => prev.filter((_, i) => i !== index))
//     toast({
//       title: "Instruction Removed",
//       description: "Instruction has been removed from the list.",
//     })
//   }

//   // Station Document handlers
//   const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
//     try {
//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       // During MPI creation, we queue the documents locally
//       const newDoc: StationDocument = {
//         file: file,
//         description: description.trim() || file.name,
//         fileName: file.name,
//         stationId: stationId,
//         isUploaded: false,
//         uploadStatus: "pending",
//       }

//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: [...(prev[stationId] || []), newDoc],
//       }))

//       toast({
//         title: "Document Queued",
//         description: `"${newDoc.description}" will be uploaded after MPI creation.`,
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: error.message || "Failed to queue document.",
//         variant: "destructive",
//       })
//       throw error
//     }
//   }

//   const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
//     }))
//     toast({
//       title: "Document Removed",
//       description: "Station document has been removed from the list.",
//     })
//   }

//   // MPI Documentation handlers
//   const handleMpiDocumentUpload = async (file: File, description: string) => {
//     setUploadingMpiDoc(true)
//     try {
//       // Validate file
//       if (!file) {
//         throw new Error("No file selected")
//       }

//       // Validate file size (10MB limit)
//       const maxSize = 10 * 1024 * 1024 // 10MB
//       if (file.size > maxSize) {
//         throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
//       }

//       const finalDescription = description.trim() || file.name

//       // Store the file locally until MPI is created - DO NOT UPLOAD
//       const newDoc: MPIDocumentation = {
//         file: file, // Store the actual file object
//         description: finalDescription,
//         fileName: file.name,
//         isUploaded: false, // Mark as not uploaded yet
//       }

//       setMpiDocumentation((prev) => {
//         const updated = [...prev, newDoc]
//         return updated
//       })

//       toast({
//         title: "✅ Document Queued",
//         description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
//       })
//     } catch (error) {
//       toast({
//         title: "❌ Error",
//         description: error.message || "Failed to queue document. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingMpiDoc(false)
//     }
//   }

//   const removeMpiDocument = (index: number) => {
//     setMpiDocumentation((prev) => {
//       const updated = prev.filter((_, i) => i !== index)
//       return updated
//     })
//     toast({
//       title: "Document Removed",
//       description: "Document has been removed from the list.",
//     })
//   }

//   const validateJobId = (jobId: string): string | null => {
//     if (!jobId.trim()) return "Job ID is required"
//     if (jobId.length < 2) return "Job ID must be at least 2 characters"
//     if (existingJobIds.includes(jobId.toLowerCase())) {
//       return `Job ID "${jobId}" already exists. Please use a different Job ID.`
//     }
//     return null
//   }

//   const validateAssemblyId = (assemblyId: string): string | null => {
//     if (!assemblyId.trim()) return "Assembly ID is required"
//     if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
//     if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
//       return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
//     }
//     return null
//   }

//   const validateDocumentControlId = (documentControlId: string): string | null => {
//     if (!documentControlId.trim()) return null
//     if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
//     if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
//       return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
//     }
//     return null
//   }

//   const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
//     setOrderFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   // Enhanced station document upload with detailed debugging
//   const uploadStationDocumentWithDebug = async (
//     mpiId: string,
//     stationId: string,
//     doc: StationDocument,
//     docIndex: number,
//   ) => {
//     // Update status to uploading
//     setStationDocuments((prev) => ({
//       ...prev,
//       [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
//     }))

//     try {
//       if (!doc.file) {
//         throw new Error("No file object found")
//       }

//       // Create FormData
//       const formData = new FormData()
//       formData.append("files", doc.file)
//       formData.append("stationId", stationId)
//       formData.append("description", doc.description)
//       formData.append("mpiId", mpiId)
//       formData.append("originalName", doc.fileName)

//       const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

//       const response = await fetch(uploadUrl, {
//         method: "POST",
//         body: formData,
//       })

//       if (!response.ok) {
//         const errorText = await response.text()
//         throw new Error(`HTTP ${response.status}: ${errorText}`)
//       }

//       const uploadResult = await response.json()

//       // Update status to success
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "success",
//                 isUploaded: true,
//                 id: uploadResult[0]?.id,
//                 fileUrl: uploadResult[0]?.fileUrl,
//               }
//             : d,
//         ),
//       }))

//       return uploadResult
//     } catch (error) {
//       // Update status to error
//       setStationDocuments((prev) => ({
//         ...prev,
//         [stationId]: prev[stationId].map((d, i) =>
//           i === docIndex
//             ? {
//                 ...d,
//                 uploadStatus: "error",
//                 uploadError: error.message,
//               }
//             : d,
//         ),
//       }))
//       throw error
//     }
//   }

//   const handleSubmit = async (e: React.FormEvent) => {
//     e.preventDefault()

//     // Validation - Reload existing IDs first
//     await loadExistingIds()

//     // Enhanced validation with better error messages
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     const validationErrors = []
//     if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
//     if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
//     if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

//     // Check for required fields
//     if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
//     if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

//     if (validationErrors.length > 0) {
//       toast({
//         title: "❌ Validation Failed",
//         description: (
//           <div className="space-y-2">
//             <p className="font-semibold">Please fix the following issues:</p>
//             <ul className="list-disc list-inside space-y-1">
//               {validationErrors.map((error, index) => (
//                 <li key={index} className="text-sm">
//                   {error}
//                 </li>
//               ))}
//             </ul>
//           </div>
//         ),
//         variant: "destructive",
//         duration: 10000,
//       })
//       setActiveTab("basic-info")
//       return
//     }

//     // Prepare submission data
//     const checklistsData =
//       checklistTemplate.length > 0
//         ? checklistTemplate
//             .map((section) => {
//               const itemsToInclude = (section.items || [])
//                 .filter((item) => {
//                   const modifications = checklistModifications[item.id]
//                   const currentRequired = modifications?.required ?? item.required
//                   return currentRequired
//                 })
//                 .map((item) => {
//                   const modifications = checklistModifications[item.id]
//                   return {
//                     description: item.description,
//                     required: modifications?.required ?? item.required,
//                     remarks: modifications?.remarks ?? item.remarks,
//                     createdBy: item.createdBy || "System",
//                     isActive: item.isActive !== undefined ? item.isActive : true,
//                     category: item.category || section.name,
//                   }
//                 })

//               return itemsToInclude.length > 0
//                 ? {
//                     name: section.name,
//                     checklistItems: itemsToInclude,
//                   }
//                 : null
//             })
//             .filter(Boolean)
//         : []

//     const stationsData = formData.selectedStationIds
//       .map((stationId) => {
//         const station = selectedStations.find((s) => s.id === stationId)
//         if (!station) return null

//         const stationSpecValues =
//           station.specifications
//             ?.map((spec) => {
//               const specValue = specificationValues[spec.id]
//               if (specValue && specValue.value) {
//                 return {
//                   specificationId: spec.id,
//                   value: specValue.value,
//                   ...(specValue.unit && { unit: specValue.unit }),
//                 }
//               }
//               return null
//             })
//             .filter(Boolean) || []

//         return {
//           id: station.id,
//           ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
//         }
//       })
//       .filter(Boolean)

//     const orderFormsData =
//       orderFormData.OrderType.length > 0 || orderFormData.selectedServiceId
//         ? [
//             {
//               // Make it an array with a single object
//               OrderType: orderFormData.OrderType || [],
//               ...(orderFormData.distributionDate && {
//                 distributionDate: new Date(orderFormData.distributionDate).toISOString(),
//               }),
//               ...(orderFormData.requiredBy && {
//                 requiredBy: new Date(orderFormData.requiredBy).toISOString(),
//               }),
//               ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
//               ...(orderFormData.revision && { revision: orderFormData.revision }),
//               ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
//               ...(orderFormData.fileAction.length > 0 && {
//                 fileAction: orderFormData.fileAction,
//               }),
//               markComplete: orderFormData.markComplete,
//               ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
//               // Add service ID mapping
//               ...(orderFormData.selectedServiceId && {
//                 serviceIds: [orderFormData.selectedServiceId], // Convert single ID to array
//               }),
//             },
//           ]
//         : undefined

//     const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

//     const submitData: CreateMPIDto = {
//       jobId: formData.jobId,
//       assemblyId: formData.assemblyId,
//     }

//     if (formData.customer && formData.customer.trim()) {
//       submitData.customer = formData.customer
//     }

//     if (validInstructions.length > 0) {
//       submitData.Instruction = validInstructions
//     }

//     if (orderFormsData) {
//       submitData.orderForms = orderFormsData
//     }

//     if (stationsData.length > 0) {
//       submitData.stations = stationsData
//     }

//     if (checklistsData.length > 0) {
//       submitData.checklists = checklistsData
//     }

//     try {
//       const result = await onSubmit(submitData)

//       // Enhanced MPI ID extraction
//       const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

//       if (!mpiId) {
//         throw new Error("MPI ID could not be extracted from creation result")
//       }

//       // Store the created MPI ID for later use
//       setCreatedMpiId(mpiId)

//       // STEP 2: Upload MPI documents
//       const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
//       if (mpiDocumentation.length > 0) {
//         for (const [index, doc] of mpiDocumentation.entries()) {
//           if (doc.file && !doc.isUploaded) {
//             try {
//               await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
//               mpiDocResults.uploaded++
//             } catch (uploadError) {
//               mpiDocResults.failed++
//               mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
//             }
//           }
//         }
//       }

//       // STEP 3: Upload Station documents
//       const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
//       const totalStationDocs = Object.keys(stationDocuments).reduce(
//         (total, stationId) => total + stationDocuments[stationId].length,
//         0,
//       )

//       if (totalStationDocs > 0) {
//         for (const [stationId, docs] of Object.entries(stationDocuments)) {
//           for (const [index, doc] of docs.entries()) {
//             if (doc.file && !doc.isUploaded) {
//               try {
//                 const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
//                 stationDocResults.uploaded++
//               } catch (uploadError) {
//                 stationDocResults.failed++
//                 const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
//                 stationDocResults.errors.push(errorMsg)
//               }
//             }
//           }
//         }

//         // STEP 4: Refresh the uploaded documents display
//         if (stationDocResults.uploaded > 0) {
//           await loadUploadedStationDocuments(mpiId)
//         }
//       }

//       // Final summary
//       const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
//       const totalFailed = mpiDocResults.failed + stationDocResults.failed
//       const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

//       if (totalFailed > 0) {
//         toast({
//           title: "⚠️ Partial Success",
//           description: (
//             <div className="space-y-2">
//               <p>
//                 MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
//               </p>
//               {allErrors.length > 0 && (
//                 <details className="text-xs">
//                   <summary>View errors</summary>
//                   <ul className="list-disc list-inside mt-1">
//                     {allErrors.slice(0, 3).map((error, i) => (
//                       <li key={i}>{error}</li>
//                     ))}
//                     {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
//                   </ul>
//                 </details>
//               )}
//             </div>
//           ),
//           variant: "destructive",
//           duration: 15000,
//         })
//       } else if (totalUploaded > 0) {
//         toast({
//           title: "✅ Complete Success",
//           description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
//           variant: "default",
//         })
//       } else {
//         toast({
//           title: "✅ Success",
//           description: "MPI created successfully!",
//           variant: "default",
//         })
//       }
//     } catch (error: any) {
//       // Handle specific error types
//       if (error.message?.includes("Unique constraint failed")) {
//         if (error.message?.includes("documentControlId")) {
//           toast({
//             title: "🚫 Duplicate Document Control ID",
//             description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("jobId")) {
//           toast({
//             title: "🚫 Duplicate Job ID",
//             description: `Job ID "${formData.jobId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         } else if (error.message?.includes("assemblyId")) {
//           toast({
//             title: "🚫 Duplicate Assembly ID",
//             description: `Assembly ID "${formData.assemblyId}" already exists.`,
//             variant: "destructive",
//             duration: 10000,
//           })
//           setActiveTab("basic-info")
//           await loadExistingIds()
//           return
//         }
//       }

//       toast({
//         title: "❌ MPI Creation Failed",
//         description: error.message || "An unexpected error occurred. Please try again.",
//         variant: "destructive",
//         duration: 10000,
//       })
//     }
//   }

//   const handleChange = (field: string, value: string) => {
//     setFormData((prev) => ({ ...prev, [field]: value }))
//   }

//   const handleStationSelectionChange = (stationIds: string[]) => {
//     setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
//   }

//   const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
//     setSpecificationValues((prev) => ({
//       ...prev,
//       [specificationId]: {
//         specificationId,
//         value,
//         ...(unit && { unit }),
//       },
//     }))
//   }

//   const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
//     const uploadKey = `${specificationId}-${stationId}`
//     setUploadingFiles((prev) => new Set(prev).add(uploadKey))

//     try {
//       const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

//       setSpecificationValues((prev) => ({
//         ...prev,
//         [specificationId]: {
//           specificationId,
//           value: result.value || result.fileUrl,
//           fileUrl: result.fileUrl,
//           ...(unit && { unit }),
//         },
//       }))

//       toast({
//         title: "Success",
//         description: "File uploaded successfully.",
//       })
//     } catch (error) {
//       toast({
//         title: "Error",
//         description: "Failed to upload file. Please try again.",
//         variant: "destructive",
//       })
//     } finally {
//       setUploadingFiles((prev) => {
//         const newSet = new Set(prev)
//         newSet.delete(uploadKey)
//         return newSet
//       })
//     }
//   }

//   const renderSpecificationInput = (spec: any, stationId: string) => {
//     const specValue = specificationValues[spec.id]
//     const uploadKey = `${spec.id}-${stationId}`
//     const isUploading = uploadingFiles.has(uploadKey)

//     // Use the same logic as the edit form
//     const inputType = spec.inputType || spec.type || "TEXT"

//     console.log(`🔍 Rendering specification input:`, {
//       specId: spec.id,
//       specName: spec.name,
//       inputType: inputType,
//       originalSpec: spec,
//     })

//     switch (inputType) {
//       case "TEXT":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )

//       case "number":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex gap-2">
//               <Input
//                 type="number"
//                 value={specValue?.value || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
//                 placeholder={`Enter ${spec.name.toLowerCase()}`}
//                 className="h-10 flex-1"
//               />
//               <Input
//                 placeholder="Unit"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-20"
//               />
//             </div>
//           </div>
//         )

//       case "CHECKBOX":
//         return (
//           <div key={spec.id} className="space-y-3">
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="flex items-center space-x-2">
//               <Checkbox
//                 checked={specValue?.value === "true"}
//                 onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
//               />
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//             </div>
//           </div>
//         )

//       case "DROPDOWN":
//         const suggestions = spec.suggestions || []
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Select
//               value={specValue?.value || ""}
//               onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
//             >
//               <SelectTrigger className="h-10">
//                 <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
//               </SelectTrigger>
//               <SelectContent>
//                 {suggestions.map((suggestion: string, index: number) => (
//                   <SelectItem key={index} value={suggestion}>
//                     {suggestion}
//                   </SelectItem>
//                 ))}
//               </SelectContent>
//             </Select>
//           </div>
//         )

//       case "FILE_UPLOAD":
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//               {specValue?.fileUrl && (
//                 <div className="flex gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(specValue.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = specValue.fileUrl
//                       link.download = `${spec.name}-${stationId}`
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               )}
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <div className="space-y-2">
//               <div className="flex items-center gap-2">
//                 <Input
//                   type="file"
//                   onChange={(e) => {
//                     const file = e.target.files?.[0]
//                     if (file) {
//                       handleFileUpload(spec.id, file, stationId, specValue?.unit)
//                     }
//                   }}
//                   accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
//                   className="cursor-pointer flex-1"
//                   disabled={isUploading}
//                 />
//                 {isUploading && (
//                   <div className="flex items-center gap-2">
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-green-600"></div>
//                     <span className="text-xs text-muted-foreground">Uploading...</span>
//                   </div>
//                 )}
//               </div>
//               <Input
//                 placeholder="Unit (optional)"
//                 value={specValue?.unit || ""}
//                 onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
//                 className="h-10 w-32"
//               />
//               {specValue?.fileUrl && (
//                 <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
//                   <FileText className="w-4 h-4 text-green-600" />
//                   <span className="text-sm text-green-800">File uploaded successfully</span>
//                 </div>
//               )}
//               <p className="text-xs text-muted-foreground">
//                 Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
//               </p>
//             </div>
//           </div>
//         )

//       default:
//         return (
//           <div key={spec.id} className="space-y-3">
//             <div className="flex items-center justify-between">
//               <Label className="text-sm font-medium">
//                 {spec.name}
//                 {spec.required && <span className="text-green-500 ml-1">*</span>}
//               </Label>
//             </div>
//             {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
//             <Input
//               value={specValue?.value || ""}
//               onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
//               placeholder={`Enter ${spec.name.toLowerCase()}`}
//               className="h-10"
//             />
//           </div>
//         )
//     }
//   }

//   const renderStationDocuments = (station: Station) => {
//     const queuedDocs = stationDocuments[station.id] || []
//     // FIXED: Get uploaded docs only for this specific station
//     const uploadedDocs = uploadedStationDocuments[station.id] || []
//     const isLoadingDocs = loadingUploadedDocs[station.id] || false

//     return (
//       <div className="space-y-4">
//         <div className="flex items-center justify-between">
//           <h4 className="font-medium">Station Documents - {station.stationName}</h4>
//           <div className="flex items-center gap-2">
//             {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
//             <span className="text-sm text-gray-500">
//               {queuedDocs.length} queued • {uploadedDocs.length} uploaded
//             </span>
//           </div>
//         </div>

//         {/* Uploaded Documents - Station Specific */}
//         {uploadedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
//             {uploadedDocs.map((doc) => (
//               <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
//                 <div className="flex items-center gap-2">
//                   <CheckCircle className="w-4 h-4 text-green-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">
//                       Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
//                     </p>
//                     <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => window.open(doc.fileUrl, "_blank")}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Eye className="w-3 h-3 mr-1" />
//                     View
//                   </Button>
//                   <Button
//                     size="sm"
//                     variant="outline"
//                     onClick={() => {
//                       const link = document.createElement("a")
//                       link.href = doc.fileUrl
//                       link.download = doc.description
//                       link.click()
//                     }}
//                     className="h-7 px-2 text-xs"
//                   >
//                     <Download className="w-3 h-3 mr-1" />
//                     Download
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Queued Documents */}
//         {queuedDocs.length > 0 && (
//           <div className="space-y-2">
//             <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
//             {queuedDocs.map((doc, index) => (
//               <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
//                 <div className="flex items-center gap-2">
//                   <FileText className="w-4 h-4 text-gray-500" />
//                   <div>
//                     <p className="text-sm font-medium">{doc.description}</p>
//                     <p className="text-xs text-gray-500">{doc.fileName}</p>
//                     <p className="text-xs text-gray-400">
//                       Status: {doc.uploadStatus || "pending"}
//                       {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
//                     </p>
//                   </div>
//                 </div>
//                 <div className="flex items-center gap-2">
//                   {doc.uploadStatus === "uploading" && (
//                     <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
//                   )}
//                   {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
//                   {doc.uploadStatus === "error" && (
//                     <AlertCircle className="w-4 h-4 text-green-500" title={doc.uploadError} />
//                   )}
//                   <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
//                     <X className="w-4 h-4" />
//                   </Button>
//                 </div>
//               </div>
//             ))}
//           </div>
//         )}

//         {/* Station-Specific Refresh Button */}
//         {createdMpiId && (
//           <Button
//             type="button"
//             variant="outline"
//             size="sm"
//             onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
//             disabled={isLoadingDocs}
//             className="w-full"
//           >
//             {isLoadingDocs ? (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
//                 Refreshing {station.stationName} Documents...
//               </>
//             ) : (
//               <>
//                 <RefreshCw className="w-4 h-4 mr-2" />
//                 Refresh {station.stationName} Documents
//               </>
//             )}
//           </Button>
//         )}
//       </div>
//     )
//   }

//   const isFormValid = () => {
//     const jobIdError = validateJobId(formData.jobId)
//     const assemblyIdError = validateAssemblyId(formData.assemblyId)
//     const documentControlIdError = orderFormData.documentControlId
//       ? validateDocumentControlId(orderFormData.documentControlId)
//       : null

//     return !jobIdError && !assemblyIdError && !documentControlIdError
//   }

//   return (
//     <div className="min-h-screen bg-gray-50">
//       <form onSubmit={handleSubmit} className="space-y-6">
//         <MPIFormHeader onCancel={onCancel} />

//         {/* MPI ID Display */}
//         {createdMpiId && (
//           <Card className="border shadow-sm">
//             <CardContent className="p-4">
//               <Alert>
//                 <CheckCircle className="h-4 w-4" />
//                 <AlertDescription>
//                   <strong>MPI Created:</strong> {createdMpiId}
//                   <Button
//                     type="button"
//                     variant="outline"
//                     size="sm"
//                     onClick={() => loadUploadedStationDocuments(createdMpiId)}
//                     disabled={refreshingData}
//                     className="ml-2"
//                   >
//                     {refreshingData ? "Refreshing..." : "Refresh Documents"}
//                   </Button>
//                 </AlertDescription>
//               </Alert>
//             </CardContent>
//           </Card>
//         )}

//         <Card className="border shadow-sm">
//           <CardContent className="p-6">
//             <MPIFormTabs
//               activeTab={activeTab}
//               onTabChange={setActiveTab}
//               documentationCount={mpiDocumentation.length}
//               checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
//               selectedStationsCount={formData.selectedStationIds.length}
//               formData={formData}
//               orderFormData={orderFormData}
//               enums={enums}
//               loadingEnums={loadingEnums}
//               checkingIds={checkingIds}
//               onFormDataChange={handleChange}
//               onOrderFormChange={handleOrderFormChange}
//               validateJobId={validateJobId}
//               validateAssemblyId={validateAssemblyId}
//               validateDocumentControlId={validateDocumentControlId}
//               mpiDocumentation={mpiDocumentation}
//               uploadingMpiDoc={uploadingMpiDoc}
//               onDocumentUpload={handleMpiDocumentUpload}
//               onRemoveDocument={removeMpiDocument}
//               toast={toast}
//               checklistTemplate={checklistTemplate}
//               loadingChecklist={loadingChecklist}
//               checklistModifications={checklistModifications}
//               onChecklistItemChange={handleChecklistItemChange}
//               getChecklistItemValue={getChecklistItemValue}
//               availableStations={availableStations}
//               selectedStationIds={formData.selectedStationIds}
//               loadingStations={loadingStations}
//               activeStationId={activeStationId}
//               stationViewMode={stationViewMode}
//               specificationValues={specificationValues}
//               uploadingFiles={uploadingFiles}
//               onStationSelectionChange={handleStationSelectionChange}
//               onActiveStationChange={setActiveStationId}
//               onStationViewModeChange={setStationViewMode}
//               onSpecificationValueChange={handleSpecificationValueChange}
//               onFileUpload={handleFileUpload}
//               renderSpecificationInput={renderSpecificationInput}
//               renderStationDocuments={renderStationDocuments}
//               instructions={instructions}
//               onAddInstruction={handleAddInstruction}
//               onInstructionChange={handleInstructionChange}
//               onRemoveInstruction={handleRemoveInstruction}
//               stationDocuments={stationDocuments}
//               onStationDocumentUpload={handleStationDocumentUpload}
//               onStationDocumentRemove={handleStationDocumentRemove}
//             />
//           </CardContent>
//         </Card>

//         <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
//       </form>
//     </div>
//   )
// }









"use client"

import { SelectItem } from "@/components/ui/select"
import { Select, SelectTrigger, SelectValue, SelectContent } from "@/components/ui/select"
import type React from "react"
import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { FileText, Download, Eye, X, AlertCircle, CheckCircle, RefreshCw } from "lucide-react"
import type { CreateMPIDto } from "./types"
import { StationAPI } from "../stations/station-api"
import type { Station } from "../stations/types"
import { useToast } from "@/hooks/use-toast"
import { MPIAPI } from "./mpi-api"
import { MPIFormTabs } from "./mpi-form-tabs"
import { MPIDocumentationAPI } from "./mpi-document-api"
import { MPIFormActions } from "./mpi-form-actions"
import { MPIFormHeader } from "./mpi-form-header"
import { API_BASE_URL } from "@/lib/constants"
import { Alert, AlertDescription } from "@/components/ui/alert"

interface MPIFormProps {
  onSubmit: (data: CreateMPIDto) => Promise<any>
  onCancel: () => void
  isLoading?: boolean
}

interface SpecificationValue {
  specificationId: string
  value: string
  fileUrl?: string
  unit?: string
}

interface ChecklistSection {
  id: string
  name: string
  description: string
  items: ChecklistItem[]
}

interface ChecklistItem {
  id: string
  description: string
  required: boolean
  remarks: string
  category?: string
  isActive: boolean
  createdBy: string
  sectionId: string
}

interface MPIDocumentation {
  id?: string
  file?: File
  fileUrl?: string
  description: string
  fileName: string
  isUploaded?: boolean
}

interface StationDocument {
  id?: string
  file?: File
  fileUrl?: string
  description: string
  fileName: string
  stationId: string
  isUploaded?: boolean
  uploadError?: string
  uploadStatus?: "pending" | "uploading" | "success" | "error"
}

interface UploadedStationDocument {
  id: string
  fileUrl: string
  description: string
  stationId: string
  mpiId: string
  createdAt: string
  station?: {
    id: string
    name: string
  }
}

export function MPIForm({ onSubmit, onCancel, isLoading }: MPIFormProps) {
  const [activeTab, setActiveTab] = useState("basic-info")
  const [formData, setFormData] = useState({
    jobId: "",
    assemblyId: "",
    customer: "",
    selectedStationIds: [],
  })

  // Order Form State
  const [orderFormData, setOrderFormData] = useState({
    OrderType: [] as string[], // Changed from orderType to OrderType
    distributionDate: "",
    requiredBy: "",
    internalOrderNumber: "",
    revision: "",
    otherAttachments: "",
    fileAction: [] as string[],
    markComplete: false,
    documentControlId: "",
    selectedServiceId: "",
  })

  // MPI Documentation State
  const [mpiDocumentation, setMpiDocumentation] = useState<MPIDocumentation[]>([])
  const [uploadingMpiDoc, setUploadingMpiDoc] = useState(false)

  // Station Documents State
  const [stationDocuments, setStationDocuments] = useState<Record<string, StationDocument[]>>({})
  const [uploadedStationDocuments, setUploadedStationDocuments] = useState<Record<string, UploadedStationDocument[]>>(
    {},
  )
  const [loadingUploadedDocs, setLoadingUploadedDocs] = useState<Record<string, boolean>>({})
  const [availableStations, setAvailableStations] = useState<Station[]>([])
  const [loadingStations, setLoadingStations] = useState(false)
  const [selectedStations, setSelectedStations] = useState<Station[]>([])
  const { toast } = useToast()

  // Enums state
  const [enums, setEnums] = useState<any>({})
  const [loadingEnums, setLoadingEnums] = useState(false)

  // Specification values state
  const [specificationValues, setSpecificationValues] = useState<Record<string, SpecificationValue>>({})
  const [uploadingFiles, setUploadingFiles] = useState<Set<string>>(new Set())
  const [existingJobIds, setExistingJobIds] = useState<string[]>([])
  const [existingAssemblyIds, setExistingAssemblyIds] = useState<string[]>([])
  const [checkingIds, setCheckingIds] = useState(false)
  const [existingDocumentControlIds, setExistingDocumentControlIds] = useState<string[]>([])

  // Checklist state
  const [checklistTemplate, setChecklistTemplate] = useState<ChecklistSection[]>([])
  const [loadingChecklist, setLoadingChecklist] = useState(false)
  const [checklistData, setChecklistData] = useState<Record<string, any>>({})
  const [checklistModifications, setChecklistModifications] = useState<
    Record<string, { required: boolean; remarks: string }>
  >({})

  // Instructions state
  const [instructions, setInstructions] = useState<string[]>([])
  const [activeStationId, setActiveStationId] = useState<string | null>(null)
  const [stationViewMode, setStationViewMode] = useState<"specifications" | "documents" | "notes">("specifications")

  // Post-upload state
  const [createdMpiId, setCreatedMpiId] = useState<string | null>(null)
  const [refreshingData, setRefreshingData] = useState(false)

  useEffect(() => {
    loadStations()
    loadEnums()
    loadExistingIds()
    loadChecklistTemplate()
  }, [])

  useEffect(() => {
    const selected = availableStations.filter((station) => formData.selectedStationIds.includes(station.id))
    setSelectedStations(selected)
  }, [formData.selectedStationIds, availableStations])

  // Load uploaded station documents when MPI is created
  useEffect(() => {
    if (createdMpiId && formData.selectedStationIds.length > 0) {
      loadUploadedStationDocuments(createdMpiId)
    }
  }, [createdMpiId, formData.selectedStationIds])

  const loadStations = async () => {
    try {
      setLoadingStations(true)
      const stations = await StationAPI.getAllStations()
      setAvailableStations(stations)
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load stations. Please try again.",
        variant: "destructive",
      })
    } finally {
      setLoadingStations(false)
    }
  }

  const loadEnums = async () => {
    try {
      setLoadingEnums(true)
      const enumsData = await MPIAPI.getEnums()
      setEnums(enumsData)
    } catch (error) {
      toast({
        title: "Warning",
        description: "Failed to load form options.",
        variant: "destructive",
      })
    } finally {
      setLoadingEnums(false)
    }
  }

  const loadExistingIds = async () => {
    try {
      setCheckingIds(true)
      const mpis = await MPIAPI.getAllMPIs()
      const jobIds = mpis.map((mpi) => mpi.jobId.toLowerCase())
      const assemblyIds = mpis.map((mpi) => mpi.assemblyId.toLowerCase())
      const documentControlIds = mpis
        .filter((mpi) => mpi.orderForms && mpi.orderForms.length > 0)
        .flatMap((mpi) => mpi.orderForms.map((form) => form.documentControlId))
        .filter(Boolean)
        .map((id) => id.toLowerCase())

      setExistingJobIds(jobIds)
      setExistingAssemblyIds(assemblyIds)
      setExistingDocumentControlIds(documentControlIds)
    } catch (error) {
      // Error handling without debug logging
    } finally {
      setCheckingIds(false)
    }
  }

  const loadChecklistTemplate = async () => {
    try {
      setLoadingChecklist(true)
      const template = await MPIAPI.getChecklistTemplate()
      if (template && Array.isArray(template)) {
        const validSections = template
          .filter(
            (section) =>
              section && typeof section === "object" && section.name && Array.isArray(section.checklistItems),
          )
          .map((section, sectionIndex) => ({
            id: `section-${sectionIndex}`,
            name: section.name,
            description: `${section.name} quality control items`,
            items: (section.checklistItems || []).map((item: any, itemIndex: number) => ({
              id: `${section.name.toLowerCase().replace(/\s+/g, "-")}-${itemIndex}`,
              description: item.description || "No description",
              required: true,
              remarks: "",
              category: item.category || section.name,
              isActive: item.isActive !== undefined ? item.isActive : true,
              createdBy: item.createdBy || "System",
              sectionId: `section-${sectionIndex}`,
            })),
          }))

        setChecklistTemplate(validSections)
      } else {
        setChecklistTemplate([])
      }
    } catch (error) {
      toast({
        title: "Warning",
        description: "Failed to load checklist template. Using default checklist.",
        variant: "destructive",
      })
    } finally {
      setLoadingChecklist(false)
    }
  }

  const loadUploadedStationDocuments = async (mpiId: string, specificStationId?: string) => {
    try {
      // If specific station ID is provided, only load for that station
      const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds

      for (const stationId of stationsToLoad) {
        // Skip if already loading for this station
        if (loadingUploadedDocs[stationId]) {
          continue
        }

        setLoadingUploadedDocs((prev) => ({ ...prev, [stationId]: true }))

        // Load documents for this specific station
        const response = await fetch(`${API_BASE_URL}/station-mpi-documents/by-station/${stationId}?mpiId=${mpiId}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        })

        if (!response.ok) {
          if (response.status === 404) {
            // No documents found for this station - that's okay
            setUploadedStationDocuments((prev) => ({ ...prev, [stationId]: [] }))
            continue
          }
          throw new Error(`Failed to fetch station documents: ${response.status}`)
        }

        const documents = await response.json()

        // Filter to only include documents for this MPI
        const filteredDocs = documents.filter((doc: any) => doc.mpiId === mpiId)

        setUploadedStationDocuments((prev) => ({
          ...prev,
          [stationId]: filteredDocs,
        }))
      }

      // Show success message with total document count
      const totalDocs = Object.values(uploadedStationDocuments).flat().length
      if (totalDocs > 0) {
        toast({
          title: "📁 Documents Loaded",
          description: `Found ${totalDocs} uploaded station document(s) for this MPI.`,
          variant: "default",
        })
      }
    } catch (error) {
      toast({
        title: "Warning",
        description: "Failed to load uploaded station documents.",
        variant: "destructive",
      })
    } finally {
      // Clear loading states
      setLoadingUploadedDocs((prev) => {
        const newState = { ...prev }
        const stationsToLoad = specificStationId ? [specificStationId] : formData.selectedStationIds
        stationsToLoad.forEach((stationId) => {
          newState[stationId] = false
        })
        return newState
      })
    }
  }

  const handleChecklistItemChange = (itemId: string, field: "required" | "remarks", value: boolean | string) => {
    setChecklistModifications((prev) => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        [field]: value,
      },
    }))
  }

  const getChecklistItemValue = (itemId: string, field: "required" | "remarks", defaultValue: boolean | string) => {
    return checklistModifications[itemId]?.[field] ?? defaultValue
  }

  // Instruction handlers
  const handleAddInstruction = () => {
    setInstructions((prev) => [...prev, ""])
  }

  const handleInstructionChange = (index: number, value: string) => {
    setInstructions((prev) => prev.map((instruction, i) => (i === index ? value : instruction)))
  }

  const handleRemoveInstruction = (index: number) => {
    setInstructions((prev) => prev.filter((_, i) => i !== index))
    toast({
      title: "Instruction Removed",
      description: "Instruction has been removed from the list.",
    })
  }

  // Station Document handlers
  const handleStationDocumentUpload = async (stationId: string, file: File, description: string) => {
    try {
      // Validate file size (10MB limit)
      const maxSize = 10 * 1024 * 1024 // 10MB
      if (file.size > maxSize) {
        throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
      }

      // During MPI creation, we queue the documents locally
      const newDoc: StationDocument = {
        file: file,
        description: description.trim() || file.name,
        fileName: file.name,
        stationId: stationId,
        isUploaded: false,
        uploadStatus: "pending",
      }

      setStationDocuments((prev) => ({
        ...prev,
        [stationId]: [...(prev[stationId] || []), newDoc],
      }))

      toast({
        title: "Document Queued",
        description: `"${newDoc.description}" will be uploaded after MPI creation.`,
      })
    } catch (error) {
      toast({
        title: "Error",
        description: error.message || "Failed to queue document.",
        variant: "destructive",
      })
      throw error
    }
  }

  const handleStationDocumentRemove = (stationId: string, documentIndex: number) => {
    setStationDocuments((prev) => ({
      ...prev,
      [stationId]: (prev[stationId] || []).filter((_, index) => index !== documentIndex),
    }))
    toast({
      title: "Document Removed",
      description: "Station document has been removed from the list.",
    })
  }

  // MPI Documentation handlers
  const handleMpiDocumentUpload = async (file: File, description: string) => {
    setUploadingMpiDoc(true)
    try {
      // Validate file
      if (!file) {
        throw new Error("No file selected")
      }

      // Validate file size (10MB limit)
      const maxSize = 10 * 1024 * 1024 // 10MB
      if (file.size > maxSize) {
        throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit`)
      }

      const finalDescription = description.trim() || file.name

      // Store the file locally until MPI is created - DO NOT UPLOAD
      const newDoc: MPIDocumentation = {
        file: file, // Store the actual file object
        description: finalDescription,
        fileName: file.name,
        isUploaded: false, // Mark as not uploaded yet
      }

      setMpiDocumentation((prev) => {
        const updated = [...prev, newDoc]
        return updated
      })

      toast({
        title: "✅ Document Queued",
        description: `"${finalDescription}" has been queued and will be uploaded AFTER the MPI is created.`,
      })
    } catch (error) {
      toast({
        title: "❌ Error",
        description: error.message || "Failed to queue document. Please try again.",
        variant: "destructive",
      })
    } finally {
      setUploadingMpiDoc(false)
    }
  }

  const removeMpiDocument = (index: number) => {
    setMpiDocumentation((prev) => {
      const updated = prev.filter((_, i) => i !== index)
      return updated
    })
    toast({
      title: "Document Removed",
      description: "Document has been removed from the list.",
    })
  }

  const validateJobId = (jobId: string): string | null => {
    if (!jobId.trim()) return "Job ID is required"
    if (jobId.length < 2) return "Job ID must be at least 2 characters"
    if (existingJobIds.includes(jobId.toLowerCase())) {
      return `Job ID "${jobId}" already exists. Please use a different Job ID.`
    }
    return null
  }

  const validateAssemblyId = (assemblyId: string): string | null => {
    if (!assemblyId.trim()) return "Assembly ID is required"
    if (assemblyId.length < 2) return "Assembly ID must be at least 2 characters"
    if (existingAssemblyIds.includes(assemblyId.toLowerCase())) {
      return `Assembly ID "${assemblyId}" already exists. Please use a different Assembly ID.`
    }
    return null
  }

  const validateDocumentControlId = (documentControlId: string): string | null => {
    if (!documentControlId.trim()) return null
    if (documentControlId.length < 2) return "Document Control ID must be at least 2 characters"
    if (existingDocumentControlIds.includes(documentControlId.toLowerCase())) {
      return `Document Control ID "${documentControlId}" already exists. Please use a different ID.`
    }
    return null
  }

  const handleOrderFormChange = (field: string, value: string | boolean | string[]) => {
    setOrderFormData((prev) => ({ ...prev, [field]: value }))
  }

  // Enhanced station document upload with detailed debugging
  const uploadStationDocumentWithDebug = async (
    mpiId: string,
    stationId: string,
    doc: StationDocument,
    docIndex: number,
  ) => {
    // Update status to uploading
    setStationDocuments((prev) => ({
      ...prev,
      [stationId]: prev[stationId].map((d, i) => (i === docIndex ? { ...d, uploadStatus: "uploading" } : d)),
    }))

    try {
      if (!doc.file) {
        throw new Error("No file object found")
      }

      // Create FormData
      const formData = new FormData()
      formData.append("files", doc.file)
      formData.append("stationId", stationId)
      formData.append("description", doc.description)
      formData.append("mpiId", mpiId)
      formData.append("originalName", doc.fileName)

      const uploadUrl = `${API_BASE_URL}/station-mpi-documents/upload`

      const response = await fetch(uploadUrl, {
        method: "POST",
        body: formData,
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`HTTP ${response.status}: ${errorText}`)
      }

      const uploadResult = await response.json()

      // Update status to success
      setStationDocuments((prev) => ({
        ...prev,
        [stationId]: prev[stationId].map((d, i) =>
          i === docIndex
            ? {
                ...d,
                uploadStatus: "success",
                isUploaded: true,
                id: uploadResult[0]?.id,
                fileUrl: uploadResult[0]?.fileUrl,
              }
            : d,
        ),
      }))

      return uploadResult
    } catch (error) {
      // Update status to error
      setStationDocuments((prev) => ({
        ...prev,
        [stationId]: prev[stationId].map((d, i) =>
          i === docIndex
            ? {
                ...d,
                uploadStatus: "error",
                uploadError: error.message,
              }
            : d,
        ),
      }))
      throw error
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    // Validation - Reload existing IDs first
    await loadExistingIds()

    // Enhanced validation with better error messages
    const jobIdError = validateJobId(formData.jobId)
    const assemblyIdError = validateAssemblyId(formData.assemblyId)
    const documentControlIdError = orderFormData.documentControlId
      ? validateDocumentControlId(orderFormData.documentControlId)
      : null

    const validationErrors = []
    if (jobIdError) validationErrors.push(`Job ID: ${jobIdError}`)
    if (assemblyIdError) validationErrors.push(`Assembly ID: ${assemblyIdError}`)
    if (documentControlIdError) validationErrors.push(`Document Control ID: ${documentControlIdError}`)

    // Check for required fields
    if (!formData.jobId.trim()) validationErrors.push("Job ID is required")
    if (!formData.assemblyId.trim()) validationErrors.push("Assembly ID is required")

    if (validationErrors.length > 0) {
      toast({
        title: "❌ Validation Failed",
        description: (
          <div className="space-y-2">
            <p className="font-semibold">Please fix the following issues:</p>
            <ul className="list-disc list-inside space-y-1">
              {validationErrors.map((error, index) => (
                <li key={index} className="text-sm">
                  {error}
                </li>
              ))}
            </ul>
          </div>
        ),
        variant: "destructive",
        duration: 10000,
      })
      setActiveTab("basic-info")
      return
    }

    // Prepare submission data
    const checklistsData =
      checklistTemplate.length > 0
        ? checklistTemplate
            .map((section) => {
              const itemsToInclude = (section.items || [])
                .filter((item) => {
                  const modifications = checklistModifications[item.id]
                  const currentRequired = modifications?.required ?? item.required
                  return currentRequired
                })
                .map((item) => {
                  const modifications = checklistModifications[item.id]
                  return {
                    description: item.description,
                    required: modifications?.required ?? item.required,
                    remarks: modifications?.remarks ?? item.remarks,
                    createdBy: item.createdBy || "System",
                    isActive: item.isActive !== undefined ? item.isActive : true,
                    category: item.category || section.name,
                  }
                })

              return itemsToInclude.length > 0
                ? {
                    name: section.name,
                    checklistItems: itemsToInclude,
                  }
                : null
            })
            .filter(Boolean)
        : []

    const stationsData = formData.selectedStationIds
      .map((stationId) => {
        const station = selectedStations.find((s) => s.id === stationId)
        if (!station) return null

        const stationSpecValues =
          station.specifications
            ?.map((spec) => {
              const specValue = specificationValues[spec.id]
              if (specValue && specValue.value) {
                return {
                  specificationId: spec.id,
                  value: specValue.value,
                  ...(specValue.unit && { unit: specValue.unit }),
                }
              }
              return null
            })
            .filter(Boolean) || []

        return {
          id: station.id,
          ...(stationSpecValues.length > 0 && { specificationValues: stationSpecValues }),
        }
      })
      .filter(Boolean)

   const orderFormsData = [
  {
    // Make it an array with a single object
    OrderType: orderFormData.OrderType || [],
    ...(orderFormData.distributionDate && {
      distributionDate: new Date(orderFormData.distributionDate).toISOString(),
    }),
    ...(orderFormData.requiredBy && {
      requiredBy: new Date(orderFormData.requiredBy).toISOString(),
    }),
    ...(orderFormData.internalOrderNumber && { internalOrderNumber: orderFormData.internalOrderNumber }),
    ...(orderFormData.revision && { revision: orderFormData.revision }),
    ...(orderFormData.otherAttachments && { otherAttachments: orderFormData.otherAttachments }),
    ...(orderFormData.fileAction.length > 0 && {
      fileAction: orderFormData.fileAction,
    }),
    markComplete: orderFormData.markComplete,
    ...(orderFormData.documentControlId && { documentControlId: orderFormData.documentControlId }),
    // Add service ID mapping
    ...(orderFormData.selectedServiceId && {
      serviceIds: [orderFormData.selectedServiceId], // Convert single ID to array
    }),
  },
]

    const validInstructions = instructions.filter((instruction) => instruction.trim() !== "")

    const submitData: CreateMPIDto = {
      jobId: formData.jobId,
      assemblyId: formData.assemblyId,
    }

    if (formData.customer && formData.customer.trim()) {
      submitData.customer = formData.customer
    }

    if (validInstructions.length > 0) {
      submitData.Instruction = validInstructions
    }

   submitData.orderForms = orderFormsData

    if (stationsData.length > 0) {
      submitData.stations = stationsData
    }

    if (checklistsData.length > 0) {
      submitData.checklists = checklistsData
    }

    try {
      const result = await onSubmit(submitData)

      // Enhanced MPI ID extraction
      const mpiId = result?.id || result?.mpiId || result?.data?.id || result?.data?.mpiId

      if (!mpiId) {
        throw new Error("MPI ID could not be extracted from creation result")
      }

      // Store the created MPI ID for later use
      setCreatedMpiId(mpiId)

      // STEP 2: Upload MPI documents
      const mpiDocResults = { uploaded: 0, failed: 0, errors: [] }
      if (mpiDocumentation.length > 0) {
        for (const [index, doc] of mpiDocumentation.entries()) {
          if (doc.file && !doc.isUploaded) {
            try {
              await MPIDocumentationAPI.uploadDocument(mpiId, doc.file, doc.description)
              mpiDocResults.uploaded++
            } catch (uploadError) {
              mpiDocResults.failed++
              mpiDocResults.errors.push(`MPI Document "${doc.description}": ${uploadError.message}`)
            }
          }
        }
      }

      // STEP 3: Upload Station documents
      const stationDocResults = { uploaded: 0, failed: 0, errors: [] }
      const totalStationDocs = Object.keys(stationDocuments).reduce(
        (total, stationId) => total + stationDocuments[stationId].length,
        0,
      )

      if (totalStationDocs > 0) {
        for (const [stationId, docs] of Object.entries(stationDocuments)) {
          for (const [index, doc] of docs.entries()) {
            if (doc.file && !doc.isUploaded) {
              try {
                const uploadResult = await uploadStationDocumentWithDebug(mpiId, stationId, doc, index)
                stationDocResults.uploaded++
              } catch (uploadError) {
                stationDocResults.failed++
                const errorMsg = `Station document "${doc.description}": ${uploadError.message}`
                stationDocResults.errors.push(errorMsg)
              }
            }
          }
        }

        // STEP 4: Refresh the uploaded documents display
        if (stationDocResults.uploaded > 0) {
          await loadUploadedStationDocuments(mpiId)
        }
      }

      // Final summary
      const totalUploaded = mpiDocResults.uploaded + stationDocResults.uploaded
      const totalFailed = mpiDocResults.failed + stationDocResults.failed
      const allErrors = [...mpiDocResults.errors, ...stationDocResults.errors]

      if (totalFailed > 0) {
        toast({
          title: "⚠️ Partial Success",
          description: (
            <div className="space-y-2">
              <p>
                MPI created successfully. {totalUploaded} documents uploaded, {totalFailed} failed.
              </p>
              {allErrors.length > 0 && (
                <details className="text-xs">
                  <summary>View errors</summary>
                  <ul className="list-disc list-inside mt-1">
                    {allErrors.slice(0, 3).map((error, i) => (
                      <li key={i}>{error}</li>
                    ))}
                    {allErrors.length > 3 && <li>...and {allErrors.length - 3} more</li>}
                  </ul>
                </details>
              )}
            </div>
          ),
          variant: "destructive",
          duration: 15000,
        })
      } else if (totalUploaded > 0) {
        toast({
          title: "✅ Complete Success",
          description: `MPI created successfully with ${totalUploaded} document(s) uploaded!`,
          variant: "default",
        })
      } else {
        toast({
          title: "✅ Success",
          description: "MPI created successfully!",
          variant: "default",
        })
      }
    } catch (error: any) {
      // Handle specific error types
      if (error.message?.includes("Unique constraint failed")) {
        if (error.message?.includes("documentControlId")) {
          toast({
            title: "🚫 Duplicate Document Control ID",
            description: `Document Control ID "${orderFormData.documentControlId}" already exists.`,
            variant: "destructive",
            duration: 10000,
          })
          setActiveTab("basic-info")
          await loadExistingIds()
          return
        } else if (error.message?.includes("jobId")) {
          toast({
            title: "🚫 Duplicate Job ID",
            description: `Job ID "${formData.jobId}" already exists.`,
            variant: "destructive",
            duration: 10000,
          })
          setActiveTab("basic-info")
          await loadExistingIds()
          return
        } else if (error.message?.includes("assemblyId")) {
          toast({
            title: "🚫 Duplicate Assembly ID",
            description: `Assembly ID "${formData.assemblyId}" already exists.`,
            variant: "destructive",
            duration: 10000,
          })
          setActiveTab("basic-info")
          await loadExistingIds()
          return
        }
      }

      toast({
        title: "❌ MPI Creation Failed",
        description: error.message || "An unexpected error occurred. Please try again.",
        variant: "destructive",
        duration: 10000,
      })
    }
  }

  const handleChange = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }))
  }

  const handleStationSelectionChange = (stationIds: string[]) => {
    setFormData((prev) => ({ ...prev, selectedStationIds: stationIds }))
  }

  const handleSpecificationValueChange = (specificationId: string, value: string, unit?: string) => {
    setSpecificationValues((prev) => ({
      ...prev,
      [specificationId]: {
        specificationId,
        value,
        ...(unit && { unit }),
      },
    }))
  }

  const handleFileUpload = async (specificationId: string, file: File, stationId: string, unit?: string) => {
    const uploadKey = `${specificationId}-${stationId}`
    setUploadingFiles((prev) => new Set(prev).add(uploadKey))

    try {
      const result = await StationAPI.uploadStationSpecificationFile(file, specificationId, stationId, unit)

      setSpecificationValues((prev) => ({
        ...prev,
        [specificationId]: {
          specificationId,
          value: result.value || result.fileUrl,
          fileUrl: result.fileUrl,
          ...(unit && { unit }),
        },
      }))

      toast({
        title: "Success",
        description: "File uploaded successfully.",
      })
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to upload file. Please try again.",
        variant: "destructive",
      })
    } finally {
      setUploadingFiles((prev) => {
        const newSet = new Set(prev)
        newSet.delete(uploadKey)
        return newSet
      })
    }
  }

  const renderSpecificationInput = (spec: any, stationId: string) => {
    const specValue = specificationValues[spec.id]
    const uploadKey = `${spec.id}-${stationId}`
    const isUploading = uploadingFiles.has(uploadKey)

    // Use the same logic as the edit form
    const inputType = spec.inputType || spec.type || "TEXT"

    console.log(`🔍 Rendering specification input:`, {
      specId: spec.id,
      specName: spec.name,
      inputType: inputType,
      originalSpec: spec,
    })

    switch (inputType) {
      case "TEXT":
        return (
          <div key={spec.id} className="space-y-3">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
            </div>
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <Input
              value={specValue?.value || ""}
              onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
              placeholder={`Enter ${spec.name.toLowerCase()}`}
              className="h-10"
            />
          </div>
        )

      case "number":
        return (
          <div key={spec.id} className="space-y-3">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
            </div>
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <div className="flex gap-2">
              <Input
                type="number"
                value={specValue?.value || ""}
                onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value, specValue?.unit)}
                placeholder={`Enter ${spec.name.toLowerCase()}`}
                className="h-10 flex-1"
              />
              <Input
                placeholder="Unit"
                value={specValue?.unit || ""}
                onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
                className="h-10 w-20"
              />
            </div>
          </div>
        )

      case "CHECKBOX":
        return (
          <div key={spec.id} className="space-y-3">
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <div className="flex items-center space-x-2">
              <Checkbox
                checked={specValue?.value === "true"}
                onCheckedChange={(checked) => handleSpecificationValueChange(spec.id, checked ? "true" : "false")}
              />
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
            </div>
          </div>
        )

      case "DROPDOWN":
        const suggestions = spec.suggestions || []
        return (
          <div key={spec.id} className="space-y-3">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
            </div>
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <Select
              value={specValue?.value || ""}
              onValueChange={(value) => handleSpecificationValueChange(spec.id, value)}
            >
              <SelectTrigger className="h-10">
                <SelectValue placeholder={`Select ${spec.name.toLowerCase()}`} />
              </SelectTrigger>
              <SelectContent>
                {suggestions.map((suggestion: string, index: number) => (
                  <SelectItem key={index} value={suggestion}>
                    {suggestion}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )

      case "FILE_UPLOAD":
        return (
          <div key={spec.id} className="space-y-3">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
              {specValue?.fileUrl && (
                <div className="flex gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => window.open(specValue.fileUrl, "_blank")}
                    className="h-7 px-2 text-xs"
                  >
                    <Eye className="w-3 h-3 mr-1" />
                    View
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => {
                      const link = document.createElement("a")
                      link.href = specValue.fileUrl
                      link.download = `${spec.name}-${stationId}`
                      link.click()
                    }}
                    className="h-7 px-2 text-xs"
                  >
                    <Download className="w-3 h-3 mr-1" />
                    Download
                  </Button>
                </div>
              )}
            </div>
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Input
                  type="file"
                  onChange={(e) => {
                    const file = e.target.files?.[0]
                    if (file) {
                      handleFileUpload(spec.id, file, stationId, specValue?.unit)
                    }
                  }}
                  accept=".pdf,.doc,.docx,.txt,.jpg,.png,.gif,.svg"
                  className="cursor-pointer flex-1"
                  disabled={isUploading}
                />
                {isUploading && (
                  <div className="flex items-center gap-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-green-600"></div>
                    <span className="text-xs text-muted-foreground">Uploading...</span>
                  </div>
                )}
              </div>
              <Input
                placeholder="Unit (optional)"
                value={specValue?.unit || ""}
                onChange={(e) => handleSpecificationValueChange(spec.id, specValue?.value || "", e.target.value)}
                className="h-10 w-32"
              />
              {specValue?.fileUrl && (
                <div className="flex items-center gap-2 p-2 bg-green-50 border border-green-200 rounded">
                  <FileText className="w-4 h-4 text-green-600" />
                  <span className="text-sm text-green-800">File uploaded successfully</span>
                </div>
              )}
              <p className="text-xs text-muted-foreground">
                Supported formats: PDF, DOC, DOCX, TXT, JPG, PNG, GIF, SVG (Max 10MB)
              </p>
            </div>
          </div>
        )

      default:
        return (
          <div key={spec.id} className="space-y-3">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium">
                {spec.name}
                {spec.required && <span className="text-green-500 ml-1">*</span>}
              </Label>
            </div>
            {spec.description && <p className="text-xs text-muted-foreground">{spec.description}</p>}
            <Input
              value={specValue?.value || ""}
              onChange={(e) => handleSpecificationValueChange(spec.id, e.target.value)}
              placeholder={`Enter ${spec.name.toLowerCase()}`}
              className="h-10"
            />
          </div>
        )
    }
  }

  const renderStationDocuments = (station: Station) => {
    const queuedDocs = stationDocuments[station.id] || []
    // FIXED: Get uploaded docs only for this specific station
    const uploadedDocs = uploadedStationDocuments[station.id] || []
    const isLoadingDocs = loadingUploadedDocs[station.id] || false

    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h4 className="font-medium">Station Documents - {station.stationName}</h4>
          <div className="flex items-center gap-2">
            {isLoadingDocs && <RefreshCw className="w-4 h-4 animate-spin" />}
            <span className="text-sm text-gray-500">
              {queuedDocs.length} queued • {uploadedDocs.length} uploaded
            </span>
          </div>
        </div>

        {/* Uploaded Documents - Station Specific */}
        {uploadedDocs.length > 0 && (
          <div className="space-y-2">
            <h5 className="text-sm font-medium text-green-700">✅ Uploaded Documents for {station.stationName}</h5>
            {uploadedDocs.map((doc) => (
              <div key={doc.id} className="flex items-center justify-between p-3 border rounded-lg bg-green-50">
                <div className="flex items-center gap-2">
                  <CheckCircle className="w-4 h-4 text-green-500" />
                  <div>
                    <p className="text-sm font-medium">{doc.description}</p>
                    <p className="text-xs text-gray-500">
                      Station: {station.stationName} • Uploaded: {new Date(doc.createdAt).toLocaleString()}
                    </p>
                    <p className="text-xs text-gray-400">MPI: {doc.mpiId}</p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => window.open(doc.fileUrl, "_blank")}
                    className="h-7 px-2 text-xs"
                  >
                    <Eye className="w-3 h-3 mr-1" />
                    View
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => {
                      const link = document.createElement("a")
                      link.href = doc.fileUrl
                      link.download = doc.description
                      link.click()
                    }}
                    className="h-7 px-2 text-xs"
                  >
                    <Download className="w-3 h-3 mr-1" />
                    Download
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Queued Documents */}
        {queuedDocs.length > 0 && (
          <div className="space-y-2">
            <h5 className="text-sm font-medium text-blue-700">📋 Queued Documents for {station.stationName}</h5>
            {queuedDocs.map((doc, index) => (
              <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                <div className="flex items-center gap-2">
                  <FileText className="w-4 h-4 text-gray-500" />
                  <div>
                    <p className="text-sm font-medium">{doc.description}</p>
                    <p className="text-xs text-gray-500">{doc.fileName}</p>
                    <p className="text-xs text-gray-400">
                      Status: {doc.uploadStatus || "pending"}
                      {doc.file && ` • ${(doc.file.size / 1024).toFixed(1)} KB`}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {doc.uploadStatus === "uploading" && (
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                  )}
                  {doc.uploadStatus === "success" && <CheckCircle className="w-4 h-4 text-green-500" />}
                  {doc.uploadStatus === "error" && (
                    <AlertCircle className="w-4 h-4 text-green-500" title={doc.uploadError} />
                  )}
                  <Button size="sm" variant="ghost" onClick={() => handleStationDocumentRemove(station.id, index)}>
                    <X className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Station-Specific Refresh Button */}
        {createdMpiId && (
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => loadUploadedStationDocuments(createdMpiId, station.id)}
            disabled={isLoadingDocs}
            className="w-full"
          >
            {isLoadingDocs ? (
              <>
                <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                Refreshing {station.stationName} Documents...
              </>
            ) : (
              <>
                <RefreshCw className="w-4 h-4 mr-2" />
                Refresh {station.stationName} Documents
              </>
            )}
          </Button>
        )}
      </div>
    )
  }

  const isFormValid = () => {
    const jobIdError = validateJobId(formData.jobId)
    const assemblyIdError = validateAssemblyId(formData.assemblyId)
    const documentControlIdError = orderFormData.documentControlId
      ? validateDocumentControlId(orderFormData.documentControlId)
      : null

    return !jobIdError && !assemblyIdError && !documentControlIdError
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <form onSubmit={handleSubmit} className="space-y-6">
        <MPIFormHeader onCancel={onCancel} />

        {/* MPI ID Display */}
        {createdMpiId && (
          <Card className="border shadow-sm">
            <CardContent className="p-4">
              <Alert>
                <CheckCircle className="h-4 w-4" />
                <AlertDescription>
                  <strong>MPI Created:</strong> {createdMpiId}
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => loadUploadedStationDocuments(createdMpiId)}
                    disabled={refreshingData}
                    className="ml-2"
                  >
                    {refreshingData ? "Refreshing..." : "Refresh Documents"}
                  </Button>
                </AlertDescription>
              </Alert>
            </CardContent>
          </Card>
        )}

        <Card className="border shadow-sm">
          <CardContent className="p-6">
            <MPIFormTabs
              activeTab={activeTab}
              onTabChange={setActiveTab}
              documentationCount={mpiDocumentation.length}
              checklistCount={checklistTemplate.reduce((total, section) => total + section.items.length, 0)}
              selectedStationsCount={formData.selectedStationIds.length}
              formData={formData}
              orderFormData={orderFormData}
              enums={enums}
              loadingEnums={loadingEnums}
              checkingIds={checkingIds}
              onFormDataChange={handleChange}
              onOrderFormChange={handleOrderFormChange}
              validateJobId={validateJobId}
              validateAssemblyId={validateAssemblyId}
              validateDocumentControlId={validateDocumentControlId}
              mpiDocumentation={mpiDocumentation}
              uploadingMpiDoc={uploadingMpiDoc}
              onDocumentUpload={handleMpiDocumentUpload}
              onRemoveDocument={removeMpiDocument}
              toast={toast}
              checklistTemplate={checklistTemplate}
              loadingChecklist={loadingChecklist}
              checklistModifications={checklistModifications}
              onChecklistItemChange={handleChecklistItemChange}
              getChecklistItemValue={getChecklistItemValue}
              availableStations={availableStations}
              selectedStationIds={formData.selectedStationIds}
              loadingStations={loadingStations}
              activeStationId={activeStationId}
              stationViewMode={stationViewMode}
              specificationValues={specificationValues}
              uploadingFiles={uploadingFiles}
              onStationSelectionChange={handleStationSelectionChange}
              onActiveStationChange={setActiveStationId}
              onStationViewModeChange={setStationViewMode}
              onSpecificationValueChange={handleSpecificationValueChange}
              onFileUpload={handleFileUpload}
              renderSpecificationInput={renderSpecificationInput}
              renderStationDocuments={renderStationDocuments}
              instructions={instructions}
              onAddInstruction={handleAddInstruction}
              onInstructionChange={handleInstructionChange}
              onRemoveInstruction={handleRemoveInstruction}
              stationDocuments={stationDocuments}
              onStationDocumentUpload={handleStationDocumentUpload}
              onStationDocumentRemove={handleStationDocumentRemove}
            />
          </CardContent>
        </Card>

        <MPIFormActions isLoading={isLoading} isFormValid={isFormValid()} onCancel={onCancel} />
      </form>
    </div>
  )
}




